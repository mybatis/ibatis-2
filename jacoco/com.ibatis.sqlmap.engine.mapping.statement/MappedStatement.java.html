<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MappedStatement.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.mapping.statement</a> &gt; <span class="el_source">MappedStatement.java</span></div><h1>MappedStatement.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.mapping.statement;

import com.ibatis.common.io.ReaderInputStream;
import com.ibatis.common.jdbc.exception.NestedSQLException;
import com.ibatis.sqlmap.client.SqlMapClient;
import com.ibatis.sqlmap.client.event.RowHandler;
import com.ibatis.sqlmap.engine.cache.CacheKey;
import com.ibatis.sqlmap.engine.execution.SqlExecutor;
import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMap;
import com.ibatis.sqlmap.engine.mapping.result.ResultMap;
import com.ibatis.sqlmap.engine.mapping.sql.Sql;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.StatementScope;
import com.ibatis.sqlmap.engine.transaction.Transaction;
import com.ibatis.sqlmap.engine.transaction.TransactionException;
import com.ibatis.sqlmap.engine.type.DomTypeMarker;
import com.ibatis.sqlmap.engine.type.XmlTypeMarker;

import java.io.StringReader;
import java.sql.Connection;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.List;

import javax.xml.XMLConstants;
import javax.xml.parsers.DocumentBuilder;
import javax.xml.parsers.DocumentBuilderFactory;

import org.w3c.dom.Document;

/**
 * The Class MappedStatement.
 */
<span class="fc" id="L51">public class MappedStatement {</span>

  /** The id. */
  private String id;

  /** The result set type. */
  private Integer resultSetType;

  /** The fetch size. */
  private Integer fetchSize;

  /** The result map. */
  private ResultMap resultMap;

  /** The parameter map. */
  private ParameterMap parameterMap;

  /** The parameter class. */
  private Class parameterClass;

  /** The sql. */
  private Sql sql;

  /** The base cache key. */
  private int baseCacheKey;

  /** The sql map client. */
  private SqlMapClientImpl sqlMapClient;

  /** The timeout. */
  private Integer timeout;

  /** The additional result maps. */
<span class="fc" id="L84">  private ResultMap[] additionalResultMaps = new ResultMap[0];</span>

  /** The execute listeners. */
<span class="fc" id="L87">  private List executeListeners = new ArrayList&lt;&gt;();</span>

  /** The resource. */
  private String resource;

  /**
   * Gets the statement type.
   *
   * @return the statement type
   */
  public StatementType getStatementType() {
<span class="nc" id="L98">    return StatementType.UNKNOWN;</span>
  }

  /**
   * Execute update.
   *
   * @param statementScope
   *          the statement scope
   * @param trans
   *          the trans
   * @param parameterObject
   *          the parameter object
   *
   * @return the int
   *
   * @throws SQLException
   *           the SQL exception
   */
  public int executeUpdate(StatementScope statementScope, Transaction trans, Object parameterObject)
      throws SQLException {
<span class="fc" id="L118">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L119">    errorContext.setActivity(&quot;preparing the mapped statement for execution&quot;);</span>
<span class="fc" id="L120">    errorContext.setObjectId(this.getId());</span>
<span class="fc" id="L121">    errorContext.setResource(this.getResource());</span>

<span class="fc" id="L123">    statementScope.getSession().setCommitRequired(true);</span>

    try {
<span class="fc" id="L126">      parameterObject = validateParameter(parameterObject);</span>

<span class="fc" id="L128">      Sql sql = getSql();</span>

<span class="fc" id="L130">      errorContext.setMoreInfo(&quot;Check the parameter map.&quot;);</span>
<span class="fc" id="L131">      ParameterMap parameterMap = sql.getParameterMap(statementScope, parameterObject);</span>

<span class="fc" id="L133">      errorContext.setMoreInfo(&quot;Check the result map.&quot;);</span>
<span class="fc" id="L134">      ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);</span>

<span class="fc" id="L136">      statementScope.setResultMap(resultMap);</span>
<span class="fc" id="L137">      statementScope.setParameterMap(parameterMap);</span>

<span class="fc" id="L139">      errorContext.setMoreInfo(&quot;Check the parameter map.&quot;);</span>
<span class="fc" id="L140">      Object[] parameters = parameterMap.getParameterObjectValues(statementScope, parameterObject);</span>

<span class="fc" id="L142">      errorContext.setMoreInfo(&quot;Check the SQL statement.&quot;);</span>
<span class="fc" id="L143">      String sqlString = sql.getSql(statementScope, parameterObject);</span>

<span class="fc" id="L145">      errorContext.setActivity(&quot;executing mapped statement&quot;);</span>
<span class="fc" id="L146">      errorContext.setMoreInfo(&quot;Check the statement or the result map.&quot;);</span>
<span class="fc" id="L147">      int rows = sqlExecuteUpdate(statementScope, trans.getConnection(), sqlString, parameters);</span>

<span class="fc" id="L149">      errorContext.setMoreInfo(&quot;Check the output parameters.&quot;);</span>
<span class="fc bfc" id="L150" title="All 2 branches covered.">      if (parameterObject != null) {</span>
<span class="fc" id="L151">        postProcessParameterObject(statementScope, parameterObject, parameters);</span>
      }

<span class="fc" id="L154">      errorContext.reset();</span>
<span class="fc" id="L155">      sql.cleanup(statementScope);</span>
<span class="fc" id="L156">      notifyListeners();</span>
<span class="fc" id="L157">      return rows;</span>
<span class="fc" id="L158">    } catch (SQLException e) {</span>
<span class="fc" id="L159">      errorContext.setCause(e);</span>
<span class="fc" id="L160">      throw new NestedSQLException(errorContext.toString(), e.getSQLState(), e.getErrorCode(), e);</span>
<span class="fc" id="L161">    } catch (Exception e) {</span>
<span class="fc" id="L162">      errorContext.setCause(e);</span>
<span class="fc" id="L163">      throw new NestedSQLException(errorContext.toString(), e);</span>
    }
  }

  /**
   * Execute query for object.
   *
   * @param statementScope
   *          the statement scope
   * @param trans
   *          the trans
   * @param parameterObject
   *          the parameter object
   * @param resultObject
   *          the result object
   *
   * @return the object
   *
   * @throws SQLException
   *           the SQL exception
   */
  public Object executeQueryForObject(StatementScope statementScope, Transaction trans, Object parameterObject,
      Object resultObject) throws SQLException {
    try {
<span class="fc" id="L187">      Object object = null;</span>

<span class="fc" id="L189">      DefaultRowHandler rowHandler = new DefaultRowHandler();</span>
<span class="fc" id="L190">      executeQueryWithCallback(statementScope, trans.getConnection(), parameterObject, resultObject, rowHandler,</span>
          SqlExecutor.NO_SKIPPED_RESULTS, SqlExecutor.NO_MAXIMUM_RESULTS);
<span class="fc" id="L192">      List list = rowHandler.getList();</span>

<span class="pc bpc" id="L194" title="1 of 2 branches missed.">      if (list.size() &gt; 1) {</span>
<span class="nc" id="L195">        throw new SQLException(&quot;Error: executeQueryForObject returned too many results.&quot;);</span>
      }
<span class="fc bfc" id="L197" title="All 2 branches covered.">      if (!list.isEmpty()) {</span>
<span class="fc" id="L198">        object = list.get(0);</span>
      }

<span class="fc" id="L201">      return object;</span>
<span class="nc" id="L202">    } catch (TransactionException e) {</span>
<span class="nc" id="L203">      throw new NestedSQLException(&quot;Error getting Connection from Transaction.  Cause: &quot; + e, e);</span>
    }
  }

  /**
   * Execute query for list.
   *
   * @param statementScope
   *          the statement scope
   * @param trans
   *          the trans
   * @param parameterObject
   *          the parameter object
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   *
   * @return the list
   *
   * @throws SQLException
   *           the SQL exception
   */
  public List executeQueryForList(StatementScope statementScope, Transaction trans, Object parameterObject,
      int skipResults, int maxResults) throws SQLException {
    try {
<span class="fc" id="L229">      DefaultRowHandler rowHandler = new DefaultRowHandler();</span>
<span class="fc" id="L230">      executeQueryWithCallback(statementScope, trans.getConnection(), parameterObject, null, rowHandler, skipResults,</span>
          maxResults);
<span class="fc" id="L232">      return rowHandler.getList();</span>
<span class="nc" id="L233">    } catch (TransactionException e) {</span>
<span class="nc" id="L234">      throw new NestedSQLException(&quot;Error getting Connection from Transaction.  Cause: &quot; + e, e);</span>
    }
  }

  /**
   * Execute query with row handler.
   *
   * @param statementScope
   *          the statement scope
   * @param trans
   *          the trans
   * @param parameterObject
   *          the parameter object
   * @param rowHandler
   *          the row handler
   *
   * @throws SQLException
   *           the SQL exception
   */
  public void executeQueryWithRowHandler(StatementScope statementScope, Transaction trans, Object parameterObject,
      RowHandler rowHandler) throws SQLException {
    try {
<span class="fc" id="L256">      executeQueryWithCallback(statementScope, trans.getConnection(), parameterObject, null, rowHandler,</span>
          SqlExecutor.NO_SKIPPED_RESULTS, SqlExecutor.NO_MAXIMUM_RESULTS);
<span class="nc" id="L258">    } catch (TransactionException e) {</span>
<span class="nc" id="L259">      throw new NestedSQLException(&quot;Error getting Connection from Transaction.  Cause: &quot; + e, e);</span>
<span class="fc" id="L260">    }</span>
<span class="fc" id="L261">  }</span>

  //
  // PROTECTED METHODS
  //

  /**
   * Execute query with callback.
   *
   * @param statementScope
   *          the statement scope
   * @param conn
   *          the conn
   * @param parameterObject
   *          the parameter object
   * @param resultObject
   *          the result object
   * @param rowHandler
   *          the row handler
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   *
   * @throws SQLException
   *           the SQL exception
   */
  protected void executeQueryWithCallback(StatementScope statementScope, Connection conn, Object parameterObject,
      Object resultObject, RowHandler rowHandler, int skipResults, int maxResults) throws SQLException {
<span class="fc" id="L290">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L291">    errorContext.setActivity(&quot;preparing the mapped statement for execution&quot;);</span>
<span class="fc" id="L292">    errorContext.setObjectId(this.getId());</span>
<span class="fc" id="L293">    errorContext.setResource(this.getResource());</span>

    try {
<span class="fc" id="L296">      parameterObject = validateParameter(parameterObject);</span>

<span class="fc" id="L298">      Sql sql = getSql();</span>

<span class="fc" id="L300">      errorContext.setMoreInfo(&quot;Check the parameter map.&quot;);</span>
<span class="fc" id="L301">      ParameterMap parameterMap = sql.getParameterMap(statementScope, parameterObject);</span>

<span class="fc" id="L303">      errorContext.setMoreInfo(&quot;Check the result map.&quot;);</span>
<span class="fc" id="L304">      ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);</span>

<span class="fc" id="L306">      statementScope.setResultMap(resultMap);</span>
<span class="fc" id="L307">      statementScope.setParameterMap(parameterMap);</span>

<span class="fc" id="L309">      errorContext.setMoreInfo(&quot;Check the parameter map.&quot;);</span>
<span class="fc" id="L310">      Object[] parameters = parameterMap.getParameterObjectValues(statementScope, parameterObject);</span>

<span class="fc" id="L312">      errorContext.setMoreInfo(&quot;Check the SQL statement.&quot;);</span>
<span class="fc" id="L313">      String sqlString = sql.getSql(statementScope, parameterObject);</span>

<span class="fc" id="L315">      errorContext.setActivity(&quot;executing mapped statement&quot;);</span>
<span class="fc" id="L316">      errorContext.setMoreInfo(&quot;Check the SQL statement or the result map.&quot;);</span>
<span class="fc" id="L317">      RowHandlerCallback callback = new RowHandlerCallback(resultMap, resultObject, rowHandler);</span>
<span class="fc" id="L318">      sqlExecuteQuery(statementScope, conn, sqlString, parameters, skipResults, maxResults, callback);</span>

<span class="fc" id="L320">      errorContext.setMoreInfo(&quot;Check the output parameters.&quot;);</span>
<span class="fc bfc" id="L321" title="All 2 branches covered.">      if (parameterObject != null) {</span>
<span class="fc" id="L322">        postProcessParameterObject(statementScope, parameterObject, parameters);</span>
      }

<span class="fc" id="L325">      errorContext.reset();</span>
<span class="fc" id="L326">      sql.cleanup(statementScope);</span>
<span class="fc" id="L327">      notifyListeners();</span>
<span class="fc" id="L328">    } catch (SQLException e) {</span>
<span class="fc" id="L329">      errorContext.setCause(e);</span>
<span class="fc" id="L330">      throw new NestedSQLException(errorContext.toString(), e.getSQLState(), e.getErrorCode(), e);</span>
<span class="nc" id="L331">    } catch (Exception e) {</span>
<span class="nc" id="L332">      errorContext.setCause(e);</span>
<span class="nc" id="L333">      throw new NestedSQLException(errorContext.toString(), e);</span>
<span class="fc" id="L334">    }</span>
<span class="fc" id="L335">  }</span>

  /**
   * Post process parameter object.
   *
   * @param statementScope
   *          the statement scope
   * @param parameterObject
   *          the parameter object
   * @param parameters
   *          the parameters
   */
  protected void postProcessParameterObject(StatementScope statementScope, Object parameterObject,
      Object[] parameters) {
<span class="fc" id="L349">  }</span>

  /**
   * Sql execute update.
   *
   * @param statementScope
   *          the statement scope
   * @param conn
   *          the conn
   * @param sqlString
   *          the sql string
   * @param parameters
   *          the parameters
   *
   * @return the int
   *
   * @throws SQLException
   *           the SQL exception
   */
  protected int sqlExecuteUpdate(StatementScope statementScope, Connection conn, String sqlString, Object[] parameters)
      throws SQLException {
<span class="fc bfc" id="L370" title="All 2 branches covered.">    if (statementScope.getSession().isInBatch()) {</span>
<span class="fc" id="L371">      getSqlExecutor().addBatch(statementScope, conn, sqlString, parameters);</span>
<span class="fc" id="L372">      return 0;</span>
    }
<span class="fc" id="L374">    return getSqlExecutor().executeUpdate(statementScope, conn, sqlString, parameters);</span>
  }

  /**
   * Sql execute query.
   *
   * @param statementScope
   *          the statement scope
   * @param conn
   *          the conn
   * @param sqlString
   *          the sql string
   * @param parameters
   *          the parameters
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  protected void sqlExecuteQuery(StatementScope statementScope, Connection conn, String sqlString, Object[] parameters,
      int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L400">    getSqlExecutor().executeQuery(statementScope, conn, sqlString, parameters, skipResults, maxResults, callback);</span>
<span class="fc" id="L401">  }</span>

  /**
   * Validate parameter.
   *
   * @param param
   *          the param
   *
   * @return the object
   *
   * @throws SQLException
   *           the SQL exception
   */
  protected Object validateParameter(Object param) throws SQLException {
<span class="fc" id="L415">    Object newParam = param;</span>
<span class="fc" id="L416">    Class parameterClass = getParameterClass();</span>
<span class="fc bfc" id="L417" title="All 4 branches covered.">    if (newParam != null &amp;&amp; parameterClass != null) {</span>
<span class="fc bfc" id="L418" title="All 2 branches covered.">      if (DomTypeMarker.class.isAssignableFrom(parameterClass)) {</span>
<span class="fc bfc" id="L419" title="All 2 branches covered.">        if (XmlTypeMarker.class.isAssignableFrom(parameterClass)) {</span>
<span class="pc bpc" id="L420" title="1 of 4 branches missed.">          if (!(newParam instanceof String) &amp;&amp; !(newParam instanceof Document)) {</span>
<span class="nc" id="L421">            throw new SQLException(&quot;Invalid parameter object type.  Expected '&quot; + String.class.getName() + &quot;' or '&quot;</span>
<span class="nc" id="L422">                + Document.class.getName() + &quot;' but found '&quot; + newParam.getClass().getName() + &quot;'.&quot;);</span>
          }
<span class="fc bfc" id="L424" title="All 2 branches covered.">          if (!(newParam instanceof Document)) {</span>
<span class="fc" id="L425">            newParam = stringToDocument((String) newParam);</span>
          }
        } else {
<span class="pc bpc" id="L428" title="1 of 2 branches missed.">          if (!Document.class.isAssignableFrom(newParam.getClass())) {</span>
<span class="nc" id="L429">            throw new SQLException(&quot;Invalid parameter object type.  Expected '&quot; + Document.class.getName()</span>
<span class="nc" id="L430">                + &quot;' but found '&quot; + newParam.getClass().getName() + &quot;'.&quot;);</span>
          }
        }
      } else {
<span class="fc bfc" id="L434" title="All 2 branches covered.">        if (!parameterClass.isAssignableFrom(newParam.getClass())) {</span>
<span class="fc" id="L435">          throw new SQLException(&quot;Invalid parameter object type.  Expected '&quot; + parameterClass.getName()</span>
<span class="fc" id="L436">              + &quot;' but found '&quot; + newParam.getClass().getName() + &quot;'.&quot;);</span>
        }
      }
    }
<span class="fc" id="L440">    return newParam;</span>
  }

  /**
   * String to document.
   *
   * @param s
   *          the s
   *
   * @return the document
   */
  private Document stringToDocument(String s) {
    try {
<span class="fc" id="L453">      DocumentBuilderFactory documentBuilderFactory = DocumentBuilderFactory.newInstance();</span>
<span class="fc" id="L454">      documentBuilderFactory.setFeature(XMLConstants.FEATURE_SECURE_PROCESSING, true);</span>
<span class="fc" id="L455">      documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_DTD, &quot;&quot;);</span>
<span class="fc" id="L456">      documentBuilderFactory.setAttribute(XMLConstants.ACCESS_EXTERNAL_SCHEMA, &quot;&quot;);</span>
<span class="fc" id="L457">      DocumentBuilder documentBuilder = documentBuilderFactory.newDocumentBuilder();</span>
<span class="fc" id="L458">      return documentBuilder.parse(new ReaderInputStream(new StringReader(s)));</span>
<span class="nc" id="L459">    } catch (Exception e) {</span>
<span class="nc" id="L460">      throw new RuntimeException(&quot;Error occurred.  Cause: &quot; + e, e);</span>
    }
  }

  /**
   * Gets the id.
   *
   * @return the id
   */
  public String getId() {
<span class="fc" id="L470">    return id;</span>
  }

  /**
   * Gets the result set type.
   *
   * @return the result set type
   */
  public Integer getResultSetType() {
<span class="fc" id="L479">    return resultSetType;</span>
  }

  /**
   * Sets the result set type.
   *
   * @param resultSetType
   *          the new result set type
   */
  public void setResultSetType(Integer resultSetType) {
<span class="nc" id="L489">    this.resultSetType = resultSetType;</span>
<span class="nc" id="L490">  }</span>

  /**
   * Gets the fetch size.
   *
   * @return the fetch size
   */
  public Integer getFetchSize() {
<span class="fc" id="L498">    return fetchSize;</span>
  }

  /**
   * Sets the fetch size.
   *
   * @param fetchSize
   *          the new fetch size
   */
  public void setFetchSize(Integer fetchSize) {
<span class="nc" id="L508">    this.fetchSize = fetchSize;</span>
<span class="nc" id="L509">  }</span>

  /**
   * Sets the id.
   *
   * @param id
   *          the new id
   */
  public void setId(String id) {
<span class="fc" id="L518">    this.id = id;</span>
<span class="fc" id="L519">  }</span>

  /**
   * Gets the sql.
   *
   * @return the sql
   */
  public Sql getSql() {
<span class="fc" id="L527">    return sql;</span>
  }

  /**
   * Sets the sql.
   *
   * @param sql
   *          the new sql
   */
  public void setSql(Sql sql) {
<span class="fc" id="L537">    this.sql = sql;</span>
<span class="fc" id="L538">  }</span>

  /**
   * Gets the result map.
   *
   * @return the result map
   */
  public ResultMap getResultMap() {
<span class="fc" id="L546">    return resultMap;</span>
  }

  /**
   * Sets the result map.
   *
   * @param resultMap
   *          the new result map
   */
  public void setResultMap(ResultMap resultMap) {
<span class="fc" id="L556">    this.resultMap = resultMap;</span>
<span class="fc" id="L557">  }</span>

  /**
   * Gets the parameter map.
   *
   * @return the parameter map
   */
  public ParameterMap getParameterMap() {
<span class="fc" id="L565">    return parameterMap;</span>
  }

  /**
   * Sets the parameter map.
   *
   * @param parameterMap
   *          the new parameter map
   */
  public void setParameterMap(ParameterMap parameterMap) {
<span class="fc" id="L575">    this.parameterMap = parameterMap;</span>
<span class="fc" id="L576">  }</span>

  /**
   * Gets the parameter class.
   *
   * @return the parameter class
   */
  public Class getParameterClass() {
<span class="fc" id="L584">    return parameterClass;</span>
  }

  /**
   * Sets the parameter class.
   *
   * @param parameterClass
   *          the new parameter class
   */
  public void setParameterClass(Class parameterClass) {
<span class="fc" id="L594">    this.parameterClass = parameterClass;</span>
<span class="fc" id="L595">  }</span>

  /**
   * Gets the resource.
   *
   * @return the resource
   */
  public String getResource() {
<span class="fc" id="L603">    return resource;</span>
  }

  /**
   * Sets the resource.
   *
   * @param resource
   *          the new resource
   */
  public void setResource(String resource) {
<span class="fc" id="L613">    this.resource = resource;</span>
<span class="fc" id="L614">  }</span>

  /**
   * Gets the cache key.
   *
   * @param statementScope
   *          the statement scope
   * @param parameterObject
   *          the parameter object
   *
   * @return the cache key
   */
  public CacheKey getCacheKey(StatementScope statementScope, Object parameterObject) {
<span class="fc" id="L627">    Sql sql = statementScope.getSql();</span>
<span class="fc" id="L628">    ParameterMap pmap = sql.getParameterMap(statementScope, parameterObject);</span>
<span class="fc" id="L629">    CacheKey cacheKey = pmap.getCacheKey(statementScope, parameterObject);</span>
<span class="fc" id="L630">    cacheKey.update(id);</span>

    // I am not sure how any clustered cache solution would ever have had any cache hits against
    // replicated objects. I could not make it happen
    // The baseCacheKey value which was being used in the update below is consistent across
    // JVMInstances on the same machine
    // but it's not consistent across machines, and therefore breaks clustered caching.

    // What would happen is the cache values were being replicated across machines but there
    // were never any cache hits for cached objects on
    // anything but the original machine an object was created on.

    // After reviewing this implementation I could not figure out why baseCacheKey is used for
    // this anyway as it's not needed, so I removed it.
    // The values used from the pmap.getCacheKey, plus id, plus the params below are unique and
    // the same across machines, so now I get replicated
    // cache hits when I force failover in my cluster

    // I wish I could make a unit test for this, but I can't do it as the old implementation
    // works on 1 machine, but fails across machines.
    // cacheKey.update(baseCacheKey);

<span class="fc" id="L652">    cacheKey.update(sql.getSql(statementScope, parameterObject)); // Fixes bug 953001</span>
<span class="fc" id="L653">    return cacheKey;</span>
  }

  /**
   * Sets the base cache key.
   *
   * @param base
   *          the new base cache key
   */
  public void setBaseCacheKey(int base) {
<span class="fc" id="L663">    this.baseCacheKey = base;</span>
<span class="fc" id="L664">  }</span>

  /**
   * Adds the execute listener.
   *
   * @param listener
   *          the listener
   */
  public void addExecuteListener(ExecuteListener listener) {
<span class="fc" id="L673">    executeListeners.add(listener);</span>
<span class="fc" id="L674">  }</span>

  /**
   * Notify listeners.
   */
  public void notifyListeners() {
<span class="fc bfc" id="L680" title="All 2 branches covered.">    for (int i = 0, n = executeListeners.size(); i &lt; n; i++) {</span>
<span class="fc" id="L681">      ((ExecuteListener) executeListeners.get(i)).onExecuteStatement(this);</span>
    }
<span class="fc" id="L683">  }</span>

  /**
   * Gets the sql executor.
   *
   * @return the sql executor
   */
  public SqlExecutor getSqlExecutor() {
<span class="fc" id="L691">    return sqlMapClient.getSqlExecutor();</span>
  }

  /**
   * Gets the sql map client.
   *
   * @return the sql map client
   */
  public SqlMapClient getSqlMapClient() {
<span class="nc" id="L700">    return sqlMapClient;</span>
  }

  /**
   * Sets the sql map client.
   *
   * @param sqlMapClient
   *          the new sql map client
   */
  public void setSqlMapClient(SqlMapClient sqlMapClient) {
<span class="fc" id="L710">    this.sqlMapClient = (SqlMapClientImpl) sqlMapClient;</span>
<span class="fc" id="L711">  }</span>

  /**
   * Inits the request.
   *
   * @param statementScope
   *          the statement scope
   */
  public void initRequest(StatementScope statementScope) {
<span class="fc" id="L720">    statementScope.setStatement(this);</span>
<span class="fc" id="L721">    statementScope.setParameterMap(parameterMap);</span>
<span class="fc" id="L722">    statementScope.setResultMap(resultMap);</span>
<span class="fc" id="L723">    statementScope.setSql(sql);</span>
<span class="fc" id="L724">  }</span>

  /**
   * Gets the timeout.
   *
   * @return the timeout
   */
  public Integer getTimeout() {
<span class="fc" id="L732">    return timeout;</span>
  }

  /**
   * Sets the timeout.
   *
   * @param timeout
   *          the new timeout
   */
  public void setTimeout(Integer timeout) {
<span class="fc" id="L742">    this.timeout = timeout;</span>
<span class="fc" id="L743">  }</span>

  /**
   * Adds the result map.
   *
   * @param resultMap
   *          the result map
   */
  public void addResultMap(ResultMap resultMap) {
<span class="fc" id="L752">    List&lt;ResultMap&gt; resultMapList = Arrays.asList(additionalResultMaps);</span>
<span class="fc" id="L753">    resultMapList = new ArrayList&lt;&gt;(resultMapList);</span>
<span class="fc" id="L754">    resultMapList.add(resultMap);</span>
<span class="fc" id="L755">    additionalResultMaps = (ResultMap[]) resultMapList.toArray(new ResultMap[resultMapList.size()]);</span>
<span class="fc" id="L756">  }</span>

  /**
   * Checks for multiple result maps.
   *
   * @return true, if successful
   */
  public boolean hasMultipleResultMaps() {
<span class="fc bfc" id="L764" title="All 2 branches covered.">    return additionalResultMaps.length &gt; 0;</span>
  }

  /**
   * Gets the additional result maps.
   *
   * @return the additional result maps
   */
  public ResultMap[] getAdditionalResultMaps() {
<span class="fc" id="L773">    return additionalResultMaps;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>