<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ResultMap.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.mapping.result</a> &gt; <span class="el_source">ResultMap.java</span></div><h1>ResultMap.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.mapping.result;

import com.ibatis.common.beans.Probe;
import com.ibatis.common.beans.ProbeFactory;
import com.ibatis.common.jdbc.exception.NestedSQLException;
import com.ibatis.sqlmap.client.SqlMapException;
import com.ibatis.sqlmap.engine.exchange.DataExchange;
import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;
import com.ibatis.sqlmap.engine.mapping.result.loader.ResultLoader;
import com.ibatis.sqlmap.engine.mapping.sql.Sql;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.StatementScope;
import com.ibatis.sqlmap.engine.type.DomCollectionTypeMarker;
import com.ibatis.sqlmap.engine.type.DomTypeMarker;
import com.ibatis.sqlmap.engine.type.TypeHandler;
import com.ibatis.sqlmap.engine.type.TypeHandlerFactory;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.StringTokenizer;

import javax.xml.parsers.DocumentBuilderFactory;
import javax.xml.parsers.ParserConfigurationException;

import org.w3c.dom.Document;

/**
 * Basic implementation of ResultMap interface.
 */
public class ResultMap {

  /** The Constant PROBE. */
<span class="fc" id="L58">  private static final Probe PROBE = ProbeFactory.getProbe();</span>

  /** The Constant KEY_SEPARATOR. */
  private static final String KEY_SEPARATOR = &quot;\002&quot;;

  /** The id. */
  private String id;

  /** The result class. */
  private Class resultClass;

  /** The result mappings. */
  // DO NOT ACCESS EITHER OF THESE OUTSIDE OF THEIR BEAN GETTER/SETTER
  private ResultMapping[] resultMappings;

  /** The remappable result mappings. */
<span class="fc" id="L74">  private ThreadLocal remappableResultMappings = new ThreadLocal();</span>

  /** The data exchange. */
  private DataExchange dataExchange;

  /** The nested result mappings. */
  private List nestedResultMappings;

  /** The discriminator. */
  private Discriminator discriminator;

  /** The group by props. */
  private Set groupByProps;

  /** The xml name. */
  private String xmlName;

  /** The resource. */
  private String resource;

  /** The delegate. */
  protected SqlMapExecutorDelegate delegate;

  /** The allow remapping. */
<span class="fc" id="L98">  protected boolean allowRemapping = false;</span>

  /** The Constant NO_VALUE. */
<span class="fc" id="L101">  public static final Object NO_VALUE = new Object();</span>

  /**
   * Constructor to pass a SqlMapExecutorDelegate in.
   *
   * @param delegate
   *          - the SqlMapExecutorDelegate
   */
<span class="fc" id="L109">  public ResultMap(SqlMapExecutorDelegate delegate) {</span>
<span class="fc" id="L110">    this.delegate = delegate;</span>
<span class="fc" id="L111">  }</span>

  /**
   * Getter for the SqlMapExecutorDelegate.
   *
   * @return - the delegate
   */
  public SqlMapExecutorDelegate getDelegate() {
<span class="fc" id="L119">    return delegate;</span>
  }

  /**
   * Gets the id.
   *
   * @return the id
   */
  public String getId() {
<span class="fc" id="L128">    return id;</span>
  }

  /**
   * Setter for the ID.
   *
   * @param id
   *          - the new ID
   */
  public void setId(String id) {
<span class="fc" id="L138">    this.id = id;</span>
<span class="fc" id="L139">  }</span>

  /**
   * Gets the result class.
   *
   * @return the result class
   */
  public Class getResultClass() {
<span class="fc" id="L147">    return resultClass;</span>
  }

  /**
   * Gets the unique key.
   *
   * @param keyPrefix
   *          the key prefix
   * @param values
   *          the values
   *
   * @return the unique key
   */
  public Object getUniqueKey(String keyPrefix, Object[] values) {
<span class="fc bfc" id="L161" title="All 2 branches covered.">    if (groupByProps != null) {</span>
      StringBuilder keyBuffer;
<span class="fc bfc" id="L163" title="All 2 branches covered.">      if (keyPrefix != null)</span>
<span class="fc" id="L164">        keyBuffer = new StringBuilder(keyPrefix);</span>
      else
<span class="fc" id="L166">        keyBuffer = new StringBuilder();</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">      for (int i = 0; i &lt; getResultMappings().length; i++) {</span>
<span class="fc" id="L168">        String propertyName = getResultMappings()[i].getPropertyName();</span>
<span class="fc bfc" id="L169" title="All 2 branches covered.">        if (groupByProps.contains(propertyName)) {</span>
<span class="fc" id="L170">          keyBuffer.append(values[i]);</span>
<span class="fc" id="L171">          keyBuffer.append('-');</span>
        }
      }
<span class="pc bpc" id="L174" title="1 of 2 branches missed.">      if (keyBuffer.length() &lt; 1) {</span>
<span class="nc" id="L175">        return null;</span>
      }
      // seperator value not likely to appear in a database
<span class="fc" id="L178">      keyBuffer.append(KEY_SEPARATOR);</span>
<span class="fc" id="L179">      return keyBuffer.toString();</span>
    }
<span class="fc" id="L181">    return null;</span>
  }

  /**
   * Gets the unique key.
   *
   * @param values
   *          the values
   *
   * @return the unique key
   */
  public Object getUniqueKey(Object[] values) {
<span class="nc" id="L193">    return getUniqueKey(null, values);</span>
  }

  /**
   * Setter for the result class (what the results will be mapped into).
   *
   * @param resultClass
   *          - the result class
   */
  public void setResultClass(Class resultClass) {
<span class="fc" id="L203">    this.resultClass = resultClass;</span>
<span class="fc" id="L204">  }</span>

  /**
   * Getter for the DataExchange object to be used.
   *
   * @return - the DataExchange object
   */
  public DataExchange getDataExchange() {
<span class="nc" id="L212">    return dataExchange;</span>
  }

  /**
   * Setter for the DataExchange object to be used.
   *
   * @param dataExchange
   *          - the new DataExchange object
   */
  public void setDataExchange(DataExchange dataExchange) {
<span class="nc" id="L222">    this.dataExchange = dataExchange;</span>
<span class="nc" id="L223">  }</span>

  /**
   * Getter (used by DomDataExchange) for the xml name of the results.
   *
   * @return - the name
   */
  public String getXmlName() {
<span class="fc" id="L231">    return xmlName;</span>
  }

  /**
   * Setter (used by the SqlMapBuilder) for the xml name of the results.
   *
   * @param xmlName
   *          - the name
   */
  public void setXmlName(String xmlName) {
<span class="fc" id="L241">    this.xmlName = xmlName;</span>
<span class="fc" id="L242">  }</span>

  /**
   * Getter for the resource (used to report errors).
   *
   * @return - the resource
   */
  public String getResource() {
<span class="fc" id="L250">    return resource;</span>
  }

  /**
   * Setter for the resource (used by the SqlMapBuilder).
   *
   * @param resource
   *          - the resource name
   */
  public void setResource(String resource) {
<span class="fc" id="L260">    this.resource = resource;</span>
<span class="fc" id="L261">  }</span>

  /**
   * Adds the group by property.
   *
   * @param name
   *          the name
   */
  public void addGroupByProperty(String name) {
<span class="pc bpc" id="L270" title="1 of 2 branches missed.">    if (groupByProps == null) {</span>
<span class="fc" id="L271">      groupByProps = new HashSet&lt;&gt;();</span>
    }
<span class="fc" id="L273">    groupByProps.add(name);</span>
<span class="fc" id="L274">  }</span>

  /**
   * Checks for group by.
   *
   * @return true, if successful
   */
  public boolean hasGroupBy() {
<span class="pc bpc" id="L282" title="1 of 4 branches missed.">    return groupByProps != null &amp;&amp; groupByProps.size() &gt; 0;</span>
  }

  /**
   * Group by props.
   *
   * @return the iterator
   */
  public Iterator groupByProps() {
<span class="fc" id="L291">    return groupByProps.iterator();</span>
  }

  /**
   * Adds the nested result mappings.
   *
   * @param mapping
   *          the mapping
   */
  public void addNestedResultMappings(ResultMapping mapping) {
<span class="fc bfc" id="L301" title="All 2 branches covered.">    if (nestedResultMappings == null) {</span>
<span class="fc" id="L302">      nestedResultMappings = new ArrayList&lt;&gt;();</span>
    }
<span class="fc" id="L304">    nestedResultMappings.add(mapping);</span>
<span class="fc" id="L305">  }</span>

  /**
   * Gets the nested result mappings.
   *
   * @return the nested result mappings
   */
  public List getNestedResultMappings() {
<span class="fc" id="L313">    return nestedResultMappings;</span>
  }

  /**
   * Gets the result mappings.
   *
   * @return the result mappings
   */
  public ResultMapping[] getResultMappings() {
<span class="fc bfc" id="L322" title="All 2 branches covered.">    if (allowRemapping) {</span>
<span class="fc" id="L323">      return (ResultMapping[]) remappableResultMappings.get();</span>
    }
<span class="fc" id="L325">    return resultMappings;</span>
  }

  /**
   * Sets the discriminator.
   *
   * @param discriminator
   *          the new discriminator
   */
  public void setDiscriminator(Discriminator discriminator) {
<span class="pc bpc" id="L335" title="1 of 2 branches missed.">    if (this.discriminator != null) {</span>
<span class="nc" id="L336">      throw new SqlMapException(&quot;A discriminator may only be set once per result map.&quot;);</span>
    }
<span class="fc" id="L338">    this.discriminator = discriminator;</span>
<span class="fc" id="L339">  }</span>

  /**
   * Gets the discriminator.
   *
   * @return the discriminator
   */
  public Discriminator getDiscriminator() {
<span class="fc" id="L347">    return discriminator;</span>
  }

  /**
   * Resolve sub map.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   *
   * @return the result map
   *
   * @throws SQLException
   *           the SQL exception
   */
  public ResultMap resolveSubMap(StatementScope statementScope, ResultSet rs) throws SQLException {
<span class="fc" id="L364">    ResultMap subMap = this;</span>
<span class="fc bfc" id="L365" title="All 2 branches covered.">    if (discriminator != null) {</span>
<span class="fc" id="L366">      ResultMapping mapping = discriminator.getResultMapping();</span>
<span class="fc" id="L367">      Object value = getPrimitiveResultMappingValue(rs, mapping);</span>
<span class="pc bpc" id="L368" title="1 of 2 branches missed.">      if (value == null) {</span>
<span class="nc" id="L369">        value = doNullMapping(value, mapping);</span>
      }
<span class="fc" id="L371">      subMap = discriminator.getSubMap(String.valueOf(value));</span>
<span class="fc bfc" id="L372" title="All 2 branches covered.">      if (subMap == null) {</span>
<span class="fc" id="L373">        subMap = this;</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">      } else if (subMap != this) {</span>
<span class="fc" id="L375">        subMap = subMap.resolveSubMap(statementScope, rs);</span>
      }
    }
<span class="fc" id="L378">    return subMap;</span>
  }

  /**
   * Setter for a list of the individual ResultMapping objects.
   *
   * @param resultMappingList
   *          - the list
   */
  public void setResultMappingList(List resultMappingList) {
<span class="fc bfc" id="L388" title="All 2 branches covered.">    if (allowRemapping) {</span>
<span class="fc" id="L389">      this.remappableResultMappings.set(resultMappingList.toArray(new ResultMapping[resultMappingList.size()]));</span>
    } else {
<span class="fc" id="L391">      this.resultMappings = (ResultMapping[]) resultMappingList.toArray(new ResultMapping[resultMappingList.size()]);</span>
    }

<span class="fc" id="L394">    Map props = new HashMap&lt;&gt;();</span>
<span class="fc" id="L395">    props.put(&quot;map&quot;, this);</span>
<span class="fc" id="L396">    dataExchange = getDelegate().getDataExchangeFactory().getDataExchangeForClass(resultClass);</span>
<span class="fc" id="L397">    dataExchange.initialize(props);</span>
<span class="fc" id="L398">  }</span>

  /**
   * Getter for the number of ResultMapping objects.
   *
   * @return - the count
   */
  public int getResultCount() {
<span class="nc" id="L406">    return this.getResultMappings().length;</span>
  }

  /**
   * Read a row from a resultset and map results to an array.
   *
   * @param statementScope
   *          scope of the request
   * @param rs
   *          ResultSet to read from
   *
   * @return row read as an array of column values.
   *
   * @throws SQLException
   *           the SQL exception
   */
  public Object[] getResults(StatementScope statementScope, ResultSet rs) throws SQLException {
<span class="fc" id="L423">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L424">    errorContext.setActivity(&quot;applying a result map&quot;);</span>
<span class="fc" id="L425">    errorContext.setObjectId(this.getId());</span>
<span class="fc" id="L426">    errorContext.setResource(this.getResource());</span>
<span class="fc" id="L427">    errorContext.setMoreInfo(&quot;Check the result map.&quot;);</span>

<span class="fc" id="L429">    boolean foundData = false;</span>
<span class="fc" id="L430">    Object[] columnValues = new Object[getResultMappings().length];</span>
<span class="fc bfc" id="L431" title="All 2 branches covered.">    for (int i = 0; i &lt; getResultMappings().length; i++) {</span>
<span class="fc" id="L432">      ResultMapping mapping = getResultMappings()[i];</span>
<span class="fc" id="L433">      errorContext.setMoreInfo(mapping.getErrorString());</span>
<span class="fc bfc" id="L434" title="All 2 branches covered.">      if (mapping.getStatementName() != null) {</span>
<span class="pc bpc" id="L435" title="1 of 2 branches missed.">        if (resultClass == null) {</span>
<span class="nc" id="L436">          throw new SqlMapException(</span>
<span class="nc" id="L437">              &quot;The result class was null when trying to get results for ResultMap named &quot; + getId() + &quot;.&quot;);</span>
        }
<span class="pc bpc" id="L439" title="1 of 2 branches missed.">        if (Map.class.isAssignableFrom(resultClass)) {</span>
<span class="nc" id="L440">          Class javaType = mapping.getJavaType();</span>
<span class="nc bnc" id="L441" title="All 2 branches missed.">          if (javaType == null) {</span>
<span class="nc" id="L442">            javaType = Object.class;</span>
          }
<span class="nc" id="L444">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, javaType);</span>
<span class="pc bfc" id="L445" title="All 2 branches covered.">        } else if (DomTypeMarker.class.isAssignableFrom(resultClass)) {</span>
<span class="fc" id="L446">          Class javaType = mapping.getJavaType();</span>
<span class="fc bfc" id="L447" title="All 2 branches covered.">          if (javaType == null) {</span>
<span class="fc" id="L448">            javaType = DomTypeMarker.class;</span>
          }
<span class="fc" id="L450">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, javaType);</span>
<span class="fc" id="L451">        } else {</span>
<span class="fc" id="L452">          Probe p = ProbeFactory.getProbe(resultClass);</span>
<span class="fc" id="L453">          Class type = p.getPropertyTypeForSetter(resultClass, mapping.getPropertyName());</span>
<span class="fc" id="L454">          columnValues[i] = getNestedSelectMappingValue(statementScope, rs, mapping, type);</span>
        }
<span class="pc bpc" id="L456" title="3 of 4 branches missed.">        foundData = foundData || columnValues[i] != null;</span>
<span class="fc bfc" id="L457" title="All 2 branches covered.">      } else if (mapping.getNestedResultMapName() == null) {</span>
<span class="fc" id="L458">        columnValues[i] = getPrimitiveResultMappingValue(rs, mapping);</span>
<span class="fc bfc" id="L459" title="All 2 branches covered.">        if (columnValues[i] == null) {</span>
<span class="fc" id="L460">          columnValues[i] = doNullMapping(columnValues[i], mapping);</span>
        } else {
<span class="fc" id="L462">          foundData = true;</span>
        }
      }
    }

<span class="fc" id="L467">    statementScope.setRowDataFound(foundData);</span>

<span class="fc" id="L469">    return columnValues;</span>
  }

  /**
   * Sets the result object values.
   *
   * @param statementScope
   *          the statement scope
   * @param resultObject
   *          the result object
   * @param values
   *          the values
   *
   * @return the object
   */
  public Object setResultObjectValues(StatementScope statementScope, Object resultObject, Object[] values) {
<span class="fc" id="L485">    final String previousNestedKey = statementScope.getCurrentNestedKey();</span>
<span class="fc" id="L486">    String ukey = (String) getUniqueKey(statementScope.getCurrentNestedKey(), values);</span>
<span class="fc" id="L487">    Map uniqueKeys = statementScope.getUniqueKeys(this);</span>
<span class="fc" id="L488">    statementScope.setCurrentNestedKey(ukey);</span>
<span class="fc bfc" id="L489" title="All 4 branches covered.">    if (uniqueKeys != null &amp;&amp; uniqueKeys.containsKey(ukey)) {</span>
      // Unique key is already known, so get the existing result object and process additional
      // results.
<span class="fc" id="L492">      resultObject = uniqueKeys.get(ukey);</span>
<span class="fc" id="L493">      applyNestedResultMap(statementScope, resultObject, values);</span>
<span class="fc" id="L494">      resultObject = NO_VALUE;</span>
<span class="pc bpc" id="L495" title="1 of 6 branches missed.">    } else if (ukey == null || uniqueKeys == null || !uniqueKeys.containsKey(ukey)) {</span>
      // Unique key is NOT known, so create a new result object and then process additional
      // results.
<span class="fc" id="L498">      resultObject = dataExchange.setData(statementScope, this, resultObject, values);</span>
      // Lazy init key set, only if we're grouped by something (i.e. ukey != null)
<span class="fc bfc" id="L500" title="All 2 branches covered.">      if (ukey != null) {</span>
<span class="fc bfc" id="L501" title="All 2 branches covered.">        if (uniqueKeys == null) {</span>
<span class="fc" id="L502">          uniqueKeys = new HashMap&lt;&gt;();</span>
<span class="fc" id="L503">          statementScope.setUniqueKeys(this, uniqueKeys);</span>
        }
<span class="fc" id="L505">        uniqueKeys.put(ukey, resultObject);</span>
      }
<span class="fc" id="L507">      applyNestedResultMap(statementScope, resultObject, values);</span>
    } else {
      // Otherwise, we don't care about these results.
<span class="nc" id="L510">      resultObject = NO_VALUE;</span>
    }

<span class="fc" id="L513">    statementScope.setCurrentNestedKey(previousNestedKey);</span>
<span class="fc" id="L514">    return resultObject;</span>
  }

  /**
   * Apply nested result map.
   *
   * @param statementScope
   *          the statement scope
   * @param resultObject
   *          the result object
   * @param values
   *          the values
   */
  private void applyNestedResultMap(StatementScope statementScope, Object resultObject, Object[] values) {
<span class="pc bpc" id="L528" title="1 of 4 branches missed.">    if (resultObject != null &amp;&amp; resultObject != NO_VALUE) {</span>
<span class="fc bfc" id="L529" title="All 2 branches covered.">      if (nestedResultMappings != null) {</span>
<span class="fc bfc" id="L530" title="All 2 branches covered.">        for (int i = 0, n = nestedResultMappings.size(); i &lt; n; i++) {</span>
<span class="fc" id="L531">          ResultMapping resultMapping = (ResultMapping) nestedResultMappings.get(i);</span>
<span class="fc" id="L532">          setNestedResultMappingValue(resultMapping, statementScope, resultObject, values);</span>
        }
      }
    }
<span class="fc" id="L536">  }</span>

  /**
   * Some changes in this method for IBATIS-225:
   * &lt;ul&gt;
   * &lt;li&gt;We no longer require the nested property to be a collection. This will allow reuses of resultMaps on 1:1
   * relationships&lt;/li&gt;
   * &lt;li&gt;If the nested property is not a collection, then it will be created/replaced by the values generated from the
   * current row.&lt;/li&gt;
   * &lt;/ul&gt;
   *
   * @param mapping
   *          the mapping
   * @param statementScope
   *          the statement scope
   * @param resultObject
   *          the result object
   * @param values
   *          the values
   */
  protected void setNestedResultMappingValue(ResultMapping mapping, StatementScope statementScope, Object resultObject,
      Object[] values) {
    try {

<span class="fc" id="L560">      String resultMapName = mapping.getNestedResultMapName();</span>
<span class="fc" id="L561">      ResultMap resultMap = getDelegate().getResultMap(resultMapName);</span>
      // get the discriminated submap if it exists
<span class="fc" id="L563">      resultMap = resultMap.resolveSubMap(statementScope, statementScope.getResultSet());</span>

<span class="fc" id="L565">      Class type = mapping.getJavaType();</span>
<span class="fc" id="L566">      String propertyName = mapping.getPropertyName();</span>

<span class="fc" id="L568">      Object obj = PROBE.getObject(resultObject, propertyName);</span>

<span class="fc bfc" id="L570" title="All 2 branches covered.">      if (obj == null) {</span>
<span class="pc bpc" id="L571" title="1 of 2 branches missed.">        if (type == null) {</span>
<span class="fc" id="L572">          type = PROBE.getPropertyTypeForSetter(resultObject, propertyName);</span>
        }

        try {
          // create the object if is it a Collection. If not a Collection
          // then we will just set the property to the object created
          // in processing the nested result map
<span class="fc bfc" id="L579" title="All 2 branches covered.">          if (Collection.class.isAssignableFrom(type)) {</span>
<span class="fc" id="L580">            obj = ResultObjectFactoryUtil.createObjectThroughFactory(type);</span>
<span class="fc" id="L581">            PROBE.setObject(resultObject, propertyName, obj);</span>
          }
<span class="nc" id="L583">        } catch (Exception e) {</span>
<span class="nc" id="L584">          throw new SqlMapException(</span>
<span class="nc" id="L585">              &quot;Error instantiating collection property for mapping '&quot; + mapping.getPropertyName() + &quot;'.  Cause: &quot; + e,</span>
              e);
<span class="fc" id="L587">        }</span>
      }

      // JIRA 375
      // &quot;Provide a way for not creating items from nested ResultMaps when the items contain only null values&quot;
<span class="fc" id="L592">      boolean subResultObjectAbsent = false;</span>
<span class="pc bpc" id="L593" title="1 of 2 branches missed.">      if (mapping.getNotNullColumn() != null) {</span>
<span class="nc bnc" id="L594" title="All 2 branches missed.">        if (statementScope.getResultSet().getObject(mapping.getNotNullColumn()) == null) {</span>
<span class="nc" id="L595">          subResultObjectAbsent = true;</span>
        }
      }
<span class="pc bpc" id="L598" title="1 of 2 branches missed.">      if (!subResultObjectAbsent) {</span>
<span class="fc" id="L599">        values = resultMap.getResults(statementScope, statementScope.getResultSet());</span>
<span class="fc bfc" id="L600" title="All 2 branches covered.">        if (statementScope.isRowDataFound()) {</span>
<span class="fc" id="L601">          Object o = resultMap.setResultObjectValues(statementScope, null, values);</span>
<span class="fc bfc" id="L602" title="All 2 branches covered.">          if (o != NO_VALUE) {</span>
<span class="fc bfc" id="L603" title="All 4 branches covered.">            if (obj != null &amp;&amp; obj instanceof Collection) {</span>
<span class="fc" id="L604">              ((Collection) obj).add(o);</span>
            } else {
<span class="fc" id="L606">              PROBE.setObject(resultObject, propertyName, o);</span>
            }
          }
        }
      }
<span class="nc" id="L611">    } catch (SQLException e) {</span>
<span class="nc" id="L612">      throw new SqlMapException(</span>
<span class="nc" id="L613">          &quot;Error getting nested result map values for '&quot; + mapping.getPropertyName() + &quot;'.  Cause: &quot; + e, e);</span>
<span class="fc" id="L614">    }</span>
<span class="fc" id="L615">  }</span>

  /**
   * Gets the nested select mapping value.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   * @param targetType
   *          the target type
   *
   * @return the nested select mapping value
   *
   * @throws SQLException
   *           the SQL exception
   */
  protected Object getNestedSelectMappingValue(StatementScope statementScope, ResultSet rs, ResultMapping mapping,
      Class targetType) throws SQLException {
    try {
<span class="fc" id="L637">      TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>

<span class="fc" id="L639">      String statementName = mapping.getStatementName();</span>
<span class="fc" id="L640">      SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>

<span class="fc" id="L642">      MappedStatement mappedStatement = client.getMappedStatement(statementName);</span>
<span class="fc" id="L643">      Class parameterType = mappedStatement.getParameterClass();</span>
<span class="fc" id="L644">      Object parameterObject = null;</span>

<span class="pc bpc" id="L646" title="1 of 2 branches missed.">      if (parameterType == null) {</span>
<span class="nc" id="L647">        parameterObject = prepareBeanParameterObject(statementScope, rs, mapping, parameterType);</span>
      } else {
<span class="fc bfc" id="L649" title="All 2 branches covered.">        if (typeHandlerFactory.hasTypeHandler(parameterType)) {</span>
<span class="fc" id="L650">          parameterObject = preparePrimitiveParameterObject(rs, mapping, parameterType);</span>
<span class="fc bfc" id="L651" title="All 2 branches covered.">        } else if (DomTypeMarker.class.isAssignableFrom(parameterType)) {</span>
<span class="fc" id="L652">          parameterObject = prepareDomParameterObject(rs, mapping);</span>
        } else {
<span class="fc" id="L654">          parameterObject = prepareBeanParameterObject(statementScope, rs, mapping, parameterType);</span>
        }
      }

<span class="fc" id="L658">      Object result = null;</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">      if (parameterObject != null) {</span>

<span class="fc" id="L661">        Sql sql = mappedStatement.getSql();</span>
<span class="fc" id="L662">        ResultMap resultMap = sql.getResultMap(statementScope, parameterObject);</span>
<span class="fc" id="L663">        Class resultClass = resultMap.getResultClass();</span>

<span class="pc bpc" id="L665" title="1 of 4 branches missed.">        if (resultClass != null &amp;&amp; !DomTypeMarker.class.isAssignableFrom(targetType)) {</span>
<span class="pc bpc" id="L666" title="1 of 2 branches missed.">          if (DomCollectionTypeMarker.class.isAssignableFrom(resultClass)) {</span>
<span class="nc" id="L667">            targetType = DomCollectionTypeMarker.class;</span>
<span class="pc bpc" id="L668" title="1 of 2 branches missed.">          } else if (DomTypeMarker.class.isAssignableFrom(resultClass)) {</span>
<span class="nc" id="L669">            targetType = DomTypeMarker.class;</span>
          }
        }

<span class="fc" id="L673">        result = ResultLoader.loadResult(client, statementName, parameterObject, targetType);</span>

<span class="fc" id="L675">        String nullValue = mapping.getNullValue();</span>
<span class="pc bpc" id="L676" title="3 of 4 branches missed.">        if (result == null &amp;&amp; nullValue != null) {</span>
<span class="nc" id="L677">          TypeHandler typeHandler = typeHandlerFactory.getTypeHandler(targetType);</span>
<span class="nc bnc" id="L678" title="All 2 branches missed.">          if (typeHandler != null) {</span>
<span class="nc" id="L679">            result = typeHandler.valueOf(nullValue);</span>
          }
        }
      }
<span class="fc" id="L683">      return result;</span>
<span class="nc" id="L684">    } catch (InstantiationException | IllegalAccessException e) {</span>
<span class="nc" id="L685">      throw new NestedSQLException(&quot;Error setting nested bean property.  Cause: &quot; + e, e);</span>
    }

  }

  /**
   * Prepare primitive parameter object.
   *
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   * @param parameterType
   *          the parameter type
   *
   * @return the object
   *
   * @throws SQLException
   *           the SQL exception
   */
  private Object preparePrimitiveParameterObject(ResultSet rs, ResultMapping mapping, Class parameterType)
      throws SQLException {
<span class="fc" id="L707">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>
<span class="fc" id="L708">    TypeHandler th = typeHandlerFactory.getTypeHandler(parameterType);</span>
<span class="fc" id="L709">    return th.getResult(rs, mapping.getColumnName());</span>
  }

  /**
   * New document.
   *
   * @param root
   *          the root
   *
   * @return the document
   */
  private Document newDocument(String root) {
    try {
<span class="fc" id="L722">      Document doc = DocumentBuilderFactory.newInstance().newDocumentBuilder().newDocument();</span>
<span class="fc" id="L723">      doc.appendChild(doc.createElement(root));</span>
<span class="fc" id="L724">      return doc;</span>
<span class="nc" id="L725">    } catch (ParserConfigurationException e) {</span>
<span class="nc" id="L726">      throw new RuntimeException(&quot;Error creating XML document.  Cause: &quot; + e);</span>
    }
  }

  /**
   * Prepare dom parameter object.
   *
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   *
   * @return the object
   *
   * @throws SQLException
   *           the SQL exception
   */
  private Object prepareDomParameterObject(ResultSet rs, ResultMapping mapping) throws SQLException {
<span class="fc" id="L744">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>

<span class="fc" id="L746">    Document doc = newDocument(&quot;parameter&quot;);</span>
<span class="fc" id="L747">    Probe probe = ProbeFactory.getProbe(doc);</span>

<span class="fc" id="L749">    String complexName = mapping.getColumnName();</span>

<span class="fc" id="L751">    TypeHandler stringTypeHandler = typeHandlerFactory.getTypeHandler(String.class);</span>
<span class="pc bpc" id="L752" title="1 of 2 branches missed.">    if (complexName.indexOf('=') &gt; -1) {</span>
      // old 1.x style multiple params
<span class="fc" id="L754">      StringTokenizer parser = new StringTokenizer(complexName, &quot;{}=, &quot;, false);</span>
<span class="fc bfc" id="L755" title="All 2 branches covered.">      while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L756">        String propName = parser.nextToken();</span>
<span class="fc" id="L757">        String colName = parser.nextToken();</span>
<span class="fc" id="L758">        Object propValue = stringTypeHandler.getResult(rs, colName);</span>
<span class="fc" id="L759">        probe.setObject(doc, propName, propValue.toString());</span>
<span class="fc" id="L760">      }</span>
<span class="fc" id="L761">    } else {</span>
      // single param
<span class="nc" id="L763">      Object propValue = stringTypeHandler.getResult(rs, complexName);</span>
<span class="nc" id="L764">      probe.setObject(doc, &quot;value&quot;, propValue.toString());</span>
    }

<span class="fc" id="L767">    return doc;</span>
  }

  /**
   * Prepare bean parameter object.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   * @param parameterType
   *          the parameter type
   *
   * @return the object
   *
   * @throws InstantiationException
   *           the instantiation exception
   * @throws IllegalAccessException
   *           the illegal access exception
   * @throws SQLException
   *           the SQL exception
   */
  private Object prepareBeanParameterObject(StatementScope statementScope, ResultSet rs, ResultMapping mapping,
      Class parameterType) throws InstantiationException, IllegalAccessException, SQLException {
<span class="fc" id="L793">    TypeHandlerFactory typeHandlerFactory = getDelegate().getTypeHandlerFactory();</span>

    Object parameterObject;
<span class="pc bpc" id="L796" title="1 of 2 branches missed.">    if (parameterType == null) {</span>
<span class="nc" id="L797">      parameterObject = new HashMap&lt;&gt;();</span>
    } else {
<span class="fc" id="L799">      parameterObject = ResultObjectFactoryUtil.createObjectThroughFactory(parameterType);</span>
    }
<span class="fc" id="L801">    String complexName = mapping.getColumnName();</span>

<span class="pc bpc" id="L803" title="3 of 4 branches missed.">    if (complexName.indexOf('=') &gt; -1 || complexName.indexOf(',') &gt; -1) {</span>
<span class="fc" id="L804">      StringTokenizer parser = new StringTokenizer(complexName, &quot;{}=, &quot;, false);</span>
<span class="fc bfc" id="L805" title="All 2 branches covered.">      while (parser.hasMoreTokens()) {</span>
<span class="fc" id="L806">        String propName = parser.nextToken();</span>
<span class="fc" id="L807">        String colName = parser.nextToken();</span>
<span class="fc" id="L808">        Class propType = PROBE.getPropertyTypeForSetter(parameterObject, propName);</span>
<span class="fc" id="L809">        TypeHandler propTypeHandler = typeHandlerFactory.getTypeHandler(propType);</span>
<span class="fc" id="L810">        Object propValue = propTypeHandler.getResult(rs, colName);</span>
<span class="fc" id="L811">        PROBE.setObject(parameterObject, propName, propValue);</span>
<span class="fc" id="L812">      }</span>
<span class="fc" id="L813">    } else {</span>
      // single param
<span class="nc" id="L815">      TypeHandler propTypeHandler = typeHandlerFactory.getTypeHandler(parameterType);</span>
<span class="nc bnc" id="L816" title="All 2 branches missed.">      if (propTypeHandler == null) {</span>
<span class="nc" id="L817">        propTypeHandler = typeHandlerFactory.getUnkownTypeHandler();</span>
      }
<span class="nc" id="L819">      parameterObject = propTypeHandler.getResult(rs, complexName);</span>
    }

<span class="fc" id="L822">    return parameterObject;</span>
  }

  /**
   * Gets the primitive result mapping value.
   *
   * @param rs
   *          the rs
   * @param mapping
   *          the mapping
   *
   * @return the primitive result mapping value
   *
   * @throws SQLException
   *           the SQL exception
   */
  protected Object getPrimitiveResultMappingValue(ResultSet rs, ResultMapping mapping) throws SQLException {
<span class="fc" id="L839">    Object value = null;</span>
<span class="fc" id="L840">    TypeHandler typeHandler = mapping.getTypeHandler();</span>
<span class="pc bpc" id="L841" title="1 of 2 branches missed.">    if (typeHandler != null) {</span>
<span class="fc" id="L842">      String columnName = mapping.getColumnName();</span>
<span class="fc" id="L843">      int columnIndex = mapping.getColumnIndex();</span>
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">      if (columnName == null) {</span>
<span class="nc" id="L845">        value = typeHandler.getResult(rs, columnIndex);</span>
      } else {
<span class="fc" id="L847">        value = typeHandler.getResult(rs, columnName);</span>
      }
<span class="fc" id="L849">    } else {</span>
<span class="nc" id="L850">      throw new SqlMapException(&quot;No type handler could be found to map the property '&quot; + mapping.getPropertyName()</span>
<span class="nc" id="L851">          + &quot;' to the column '&quot; + mapping.getColumnName()</span>
          + &quot;'.  One or both of the types, or the combination of types is not supported.&quot;);
    }
<span class="fc" id="L854">    return value;</span>
  }

  /**
   * Do null mapping.
   *
   * @param value
   *          the value
   * @param mapping
   *          the mapping
   *
   * @return the object
   *
   * @throws SqlMapException
   *           the sql map exception
   */
  protected Object doNullMapping(Object value, ResultMapping mapping) throws SqlMapException {
<span class="pc bpc" id="L871" title="1 of 2 branches missed.">    if (value == null) {</span>
<span class="fc" id="L872">      TypeHandler typeHandler = mapping.getTypeHandler();</span>
<span class="pc bpc" id="L873" title="1 of 2 branches missed.">      if (typeHandler != null) {</span>
<span class="fc" id="L874">        String nullValue = mapping.getNullValue();</span>
<span class="fc bfc" id="L875" title="All 2 branches covered.">        if (nullValue != null)</span>
<span class="fc" id="L876">          value = typeHandler.valueOf(nullValue);</span>
<span class="fc" id="L877">        return value;</span>
      }
<span class="nc" id="L879">      throw new SqlMapException(&quot;No type handler could be found to map the property '&quot; + mapping.getPropertyName()</span>
<span class="nc" id="L880">          + &quot;' to the column '&quot; + mapping.getColumnName()</span>
          + &quot;'.  One or both of the types, or the combination of types is not supported.&quot;);
    }
<span class="nc" id="L883">    return value;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>