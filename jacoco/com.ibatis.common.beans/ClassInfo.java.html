<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>ClassInfo.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.common.beans</a> &gt; <span class="el_source">ClassInfo.java</span></div><h1>ClassInfo.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.common.beans;

import java.lang.reflect.Constructor;
import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
import java.lang.reflect.ReflectPermission;
import java.lang.reflect.UndeclaredThrowableException;
import java.math.BigDecimal;
import java.math.BigInteger;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Date;
import java.util.Enumeration;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.LinkedList;
import java.util.List;
import java.util.Locale;
import java.util.Map;
import java.util.Set;
import java.util.TreeMap;
import java.util.TreeSet;
import java.util.Vector;
import java.util.concurrent.ConcurrentHashMap;

/**
 * This class represents a cached set of class definition information that allows for easy mapping between property
 * names and getter/setter methods.
 */
public class ClassInfo {

  /** The cache enabled. */
<span class="fc" id="L51">  private static boolean cacheEnabled = true;</span>

  /** The Constant EMPTY_STRING_ARRAY. */
<span class="fc" id="L54">  private static final String[] EMPTY_STRING_ARRAY = {};</span>

  /** The Constant SIMPLE_TYPE_SET. */
<span class="fc" id="L57">  private static final Set SIMPLE_TYPE_SET = new HashSet&lt;&gt;();</span>

  /** The Constant CLASS_INFO_MAP. */
<span class="fc" id="L60">  private static final Map&lt;Class, ClassInfo&gt; CLASS_INFO_MAP = new ConcurrentHashMap&lt;&gt;();</span>

  /** The class name. */
  private String className;

  /** The readable property names. */
<span class="fc" id="L66">  private String[] readablePropertyNames = EMPTY_STRING_ARRAY;</span>

  /** The writeable property names. */
<span class="fc" id="L69">  private String[] writeablePropertyNames = EMPTY_STRING_ARRAY;</span>

  /** The set methods. */
<span class="fc" id="L72">  private HashMap setMethods = new HashMap&lt;&gt;();</span>

  /** The get methods. */
<span class="fc" id="L75">  private HashMap getMethods = new HashMap&lt;&gt;();</span>

  /** The set types. */
<span class="fc" id="L78">  private HashMap setTypes = new HashMap&lt;&gt;();</span>

  /** The get types. */
<span class="fc" id="L81">  private HashMap getTypes = new HashMap&lt;&gt;();</span>

  /** The default constructor. */
  private Constructor defaultConstructor;

  static {
<span class="fc" id="L87">    SIMPLE_TYPE_SET.add(String.class);</span>
<span class="fc" id="L88">    SIMPLE_TYPE_SET.add(Byte.class);</span>
<span class="fc" id="L89">    SIMPLE_TYPE_SET.add(Short.class);</span>
<span class="fc" id="L90">    SIMPLE_TYPE_SET.add(Character.class);</span>
<span class="fc" id="L91">    SIMPLE_TYPE_SET.add(Integer.class);</span>
<span class="fc" id="L92">    SIMPLE_TYPE_SET.add(Long.class);</span>
<span class="fc" id="L93">    SIMPLE_TYPE_SET.add(Float.class);</span>
<span class="fc" id="L94">    SIMPLE_TYPE_SET.add(Double.class);</span>
<span class="fc" id="L95">    SIMPLE_TYPE_SET.add(Boolean.class);</span>
<span class="fc" id="L96">    SIMPLE_TYPE_SET.add(Date.class);</span>
<span class="fc" id="L97">    SIMPLE_TYPE_SET.add(Class.class);</span>
<span class="fc" id="L98">    SIMPLE_TYPE_SET.add(BigInteger.class);</span>
<span class="fc" id="L99">    SIMPLE_TYPE_SET.add(BigDecimal.class);</span>

<span class="fc" id="L101">    SIMPLE_TYPE_SET.add(Collection.class);</span>
<span class="fc" id="L102">    SIMPLE_TYPE_SET.add(Set.class);</span>
<span class="fc" id="L103">    SIMPLE_TYPE_SET.add(Map.class);</span>
<span class="fc" id="L104">    SIMPLE_TYPE_SET.add(List.class);</span>
<span class="fc" id="L105">    SIMPLE_TYPE_SET.add(HashMap.class);</span>
<span class="fc" id="L106">    SIMPLE_TYPE_SET.add(TreeMap.class);</span>
<span class="fc" id="L107">    SIMPLE_TYPE_SET.add(ArrayList.class);</span>
<span class="fc" id="L108">    SIMPLE_TYPE_SET.add(LinkedList.class);</span>
<span class="fc" id="L109">    SIMPLE_TYPE_SET.add(HashSet.class);</span>
<span class="fc" id="L110">    SIMPLE_TYPE_SET.add(TreeSet.class);</span>
<span class="fc" id="L111">    SIMPLE_TYPE_SET.add(Vector.class);</span>
<span class="fc" id="L112">    SIMPLE_TYPE_SET.add(Hashtable.class);</span>
<span class="fc" id="L113">    SIMPLE_TYPE_SET.add(Enumeration.class);</span>
<span class="fc" id="L114">  }</span>

  /**
   * Instantiates a new class info.
   *
   * @param clazz
   *          the clazz
   */
<span class="fc" id="L122">  private ClassInfo(Class clazz) {</span>
<span class="fc" id="L123">    className = clazz.getName();</span>
<span class="fc" id="L124">    addDefaultConstructor(clazz);</span>
<span class="fc" id="L125">    addGetMethods(clazz);</span>
<span class="fc" id="L126">    addSetMethods(clazz);</span>
<span class="fc" id="L127">    addFields(clazz);</span>
<span class="fc" id="L128">    readablePropertyNames = (String[]) getMethods.keySet().toArray(new String[getMethods.keySet().size()]);</span>
<span class="fc" id="L129">    writeablePropertyNames = (String[]) setMethods.keySet().toArray(new String[setMethods.keySet().size()]);</span>
<span class="fc" id="L130">  }</span>

  /**
   * Adds the default constructor.
   *
   * @param clazz
   *          the clazz
   */
  private void addDefaultConstructor(Class clazz) {
<span class="fc" id="L139">    Constructor[] consts = clazz.getDeclaredConstructors();</span>
<span class="fc bfc" id="L140" title="All 2 branches covered.">    for (Constructor constructor : consts) {</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">      if (constructor.getParameterTypes().length == 0) {</span>
<span class="pc bpc" id="L142" title="1 of 2 branches missed.">        if (canAccessPrivateMethods()) {</span>
          try {
<span class="fc" id="L144">            constructor.setAccessible(true);</span>
<span class="nc" id="L145">          } catch (Exception e) {</span>
            // Ignored. This is only a final precaution, nothing we can do.
<span class="fc" id="L147">          }</span>
        }
<span class="pc bpc" id="L149" title="1 of 2 branches missed.">        if (constructor.isAccessible()) {</span>
<span class="fc" id="L150">          this.defaultConstructor = constructor;</span>
        }
      }
    }
<span class="fc" id="L154">  }</span>

  /**
   * Adds the get methods.
   *
   * @param cls
   *          the cls
   */
  private void addGetMethods(Class cls) {
<span class="fc" id="L163">    Method[] methods = getClassMethods(cls);</span>
<span class="fc bfc" id="L164" title="All 2 branches covered.">    for (Method method : methods) {</span>
<span class="fc" id="L165">      String name = method.getName();</span>
<span class="pc bpc" id="L166" title="1 of 8 branches missed.">      if ((name.startsWith(&quot;get&quot;) &amp;&amp; name.length() &gt; 3) || (name.startsWith(&quot;is&quot;) &amp;&amp; name.length() &gt; 2)) {</span>
<span class="fc bfc" id="L167" title="All 2 branches covered.">        if (method.getParameterTypes().length == 0) {</span>
<span class="fc" id="L168">          name = dropCase(name);</span>
<span class="fc" id="L169">          addGetMethod(name, method);</span>
        }
      }
    }
<span class="fc" id="L173">  }</span>

  /**
   * Adds the get method.
   *
   * @param name
   *          the name
   * @param method
   *          the method
   */
  private void addGetMethod(String name, Method method) {
<span class="fc" id="L184">    getMethods.put(name, new MethodInvoker(method));</span>
<span class="fc" id="L185">    getTypes.put(name, method.getReturnType());</span>
<span class="fc" id="L186">  }</span>

  /**
   * Adds the set methods.
   *
   * @param cls
   *          the cls
   */
  private void addSetMethods(Class cls) {
<span class="fc" id="L195">    Map conflictingSetters = new HashMap&lt;&gt;();</span>
<span class="fc" id="L196">    Method[] methods = getClassMethods(cls);</span>
<span class="fc bfc" id="L197" title="All 2 branches covered.">    for (Method method : methods) {</span>
<span class="fc" id="L198">      String name = method.getName();</span>
<span class="fc bfc" id="L199" title="All 4 branches covered.">      if (name.startsWith(&quot;set&quot;) &amp;&amp; name.length() &gt; 3) {</span>
<span class="fc bfc" id="L200" title="All 2 branches covered.">        if (method.getParameterTypes().length == 1) {</span>
<span class="fc" id="L201">          name = dropCase(name);</span>
          // /------------
<span class="fc" id="L203">          addSetterConflict(conflictingSetters, name, method);</span>
          // addSetMethod(name, method);
          // /------------
        }
      }
    }
<span class="fc" id="L209">    resolveSetterConflicts(conflictingSetters);</span>
<span class="fc" id="L210">  }</span>

  /**
   * Adds the setter conflict.
   *
   * @param conflictingSetters
   *          the conflicting setters
   * @param name
   *          the name
   * @param method
   *          the method
   */
  private void addSetterConflict(Map conflictingSetters, String name, Method method) {
<span class="fc" id="L223">    List list = (List) conflictingSetters.get(name);</span>
<span class="fc bfc" id="L224" title="All 2 branches covered.">    if (list == null) {</span>
<span class="fc" id="L225">      list = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L226">      conflictingSetters.put(name, list);</span>
    }
<span class="fc" id="L228">    list.add(method);</span>
<span class="fc" id="L229">  }</span>

  /**
   * Resolve setter conflicts.
   *
   * @param conflictingSetters
   *          the conflicting setters
   */
  private void resolveSetterConflicts(Map conflictingSetters) {
<span class="fc bfc" id="L238" title="All 2 branches covered.">    for (Iterator propNames = conflictingSetters.keySet().iterator(); propNames.hasNext();) {</span>
<span class="fc" id="L239">      String propName = (String) propNames.next();</span>
<span class="fc" id="L240">      List setters = (List) conflictingSetters.get(propName);</span>
<span class="fc" id="L241">      Method firstMethod = (Method) setters.get(0);</span>
<span class="fc bfc" id="L242" title="All 2 branches covered.">      if (setters.size() == 1) {</span>
<span class="fc" id="L243">        addSetMethod(propName, firstMethod);</span>
      } else {
<span class="fc" id="L245">        Class expectedType = (Class) getTypes.get(propName);</span>
<span class="fc bfc" id="L246" title="All 2 branches covered.">        if (expectedType == null) {</span>
<span class="fc" id="L247">          throw new RuntimeException(&quot;Illegal overloaded setter method with ambiguous type for property &quot; + propName</span>
<span class="fc" id="L248">              + &quot; in class &quot; + firstMethod.getDeclaringClass() + &quot;.  This breaks the JavaBeans &quot;</span>
              + &quot;specification and can cause unpredicatble results.&quot;);
        } else {
<span class="fc" id="L251">          Iterator methods = setters.iterator();</span>
<span class="fc" id="L252">          Method setter = null;</span>
<span class="fc bfc" id="L253" title="All 2 branches covered.">          while (methods.hasNext()) {</span>
<span class="fc" id="L254">            Method method = (Method) methods.next();</span>
<span class="pc bpc" id="L255" title="1 of 4 branches missed.">            if (method.getParameterTypes().length == 1 &amp;&amp; expectedType.equals(method.getParameterTypes()[0])) {</span>
<span class="fc" id="L256">              setter = method;</span>
<span class="fc" id="L257">              break;</span>
            }
<span class="fc" id="L259">          }</span>
<span class="fc bfc" id="L260" title="All 2 branches covered.">          if (setter == null) {</span>
<span class="fc" id="L261">            throw new RuntimeException(&quot;Illegal overloaded setter method with ambiguous type for property &quot; + propName</span>
<span class="fc" id="L262">                + &quot; in class &quot; + firstMethod.getDeclaringClass() + &quot;.  This breaks the JavaBeans &quot;</span>
                + &quot;specification and can cause unpredicatble results.&quot;);
          }
<span class="fc" id="L265">          addSetMethod(propName, setter);</span>
        }
      }
<span class="fc" id="L268">    }</span>
<span class="fc" id="L269">  }</span>

  /**
   * Adds the set method.
   *
   * @param name
   *          the name
   * @param method
   *          the method
   */
  private void addSetMethod(String name, Method method) {
<span class="fc" id="L280">    setMethods.put(name, new MethodInvoker(method));</span>
<span class="fc" id="L281">    setTypes.put(name, method.getParameterTypes()[0]);</span>
<span class="fc" id="L282">  }</span>

  /**
   * Adds the fields.
   *
   * @param clazz
   *          the clazz
   */
  private void addFields(Class clazz) {
<span class="fc" id="L291">    Field[] fields = clazz.getDeclaredFields();</span>
<span class="fc bfc" id="L292" title="All 2 branches covered.">    for (Field field : fields) {</span>
<span class="pc bpc" id="L293" title="1 of 2 branches missed.">      if (canAccessPrivateMethods()) {</span>
        try {
<span class="fc" id="L295">          field.setAccessible(true);</span>
<span class="fc" id="L296">        } catch (Exception e) {</span>
          // Ignored. This is only a final precaution, nothing we can do.
<span class="fc" id="L298">        }</span>
      }
<span class="fc bfc" id="L300" title="All 2 branches covered.">      if (field.isAccessible()) {</span>
<span class="fc bfc" id="L301" title="All 2 branches covered.">        if (!setMethods.containsKey(field.getName())) {</span>
<span class="fc" id="L302">          addSetField(field);</span>
        }
<span class="fc bfc" id="L304" title="All 2 branches covered.">        if (!getMethods.containsKey(field.getName())) {</span>
<span class="fc" id="L305">          addGetField(field);</span>
        }
      }
    }
<span class="fc bfc" id="L309" title="All 2 branches covered.">    if (clazz.getSuperclass() != null) {</span>
<span class="fc" id="L310">      addFields(clazz.getSuperclass());</span>
    }
<span class="fc" id="L312">  }</span>

  /**
   * Adds the set field.
   *
   * @param field
   *          the field
   */
  private void addSetField(Field field) {
<span class="fc" id="L321">    setMethods.put(field.getName(), new SetFieldInvoker(field));</span>
<span class="fc" id="L322">    setTypes.put(field.getName(), field.getType());</span>
<span class="fc" id="L323">  }</span>

  /**
   * Adds the get field.
   *
   * @param field
   *          the field
   */
  private void addGetField(Field field) {
<span class="fc" id="L332">    getMethods.put(field.getName(), new GetFieldInvoker(field));</span>
<span class="fc" id="L333">    getTypes.put(field.getName(), field.getType());</span>
<span class="fc" id="L334">  }</span>

  /**
   * This method returns an array containing all methods declared in this class and any superclass. We use this method,
   * instead of the simpler Class.getMethods(), because we want to look for private methods as well.
   *
   * @param cls
   *          The class
   *
   * @return An array containing all methods in this class
   */
  private Method[] getClassMethods(Class cls) {
<span class="fc" id="L346">    HashMap uniqueMethods = new HashMap&lt;&gt;();</span>
<span class="fc" id="L347">    Class currentClass = cls;</span>
<span class="fc bfc" id="L348" title="All 2 branches covered.">    while (currentClass != null) {</span>
<span class="fc" id="L349">      addUniqueMethods(uniqueMethods, currentClass.getDeclaredMethods());</span>

      // we also need to look for interface methods -
      // because the class may be abstract
<span class="fc" id="L353">      Class[] interfaces = currentClass.getInterfaces();</span>
<span class="fc bfc" id="L354" title="All 2 branches covered.">      for (Class element : interfaces) {</span>
<span class="fc" id="L355">        addUniqueMethods(uniqueMethods, element.getMethods());</span>
      }

<span class="fc" id="L358">      currentClass = currentClass.getSuperclass();</span>
<span class="fc" id="L359">    }</span>

<span class="fc" id="L361">    Collection methods = uniqueMethods.values();</span>

<span class="fc" id="L363">    return (Method[]) methods.toArray(new Method[methods.size()]);</span>
  }

  /**
   * Adds the unique methods.
   *
   * @param uniqueMethods
   *          the unique methods
   * @param methods
   *          the methods
   */
  private void addUniqueMethods(HashMap uniqueMethods, Method[] methods) {
<span class="fc bfc" id="L375" title="All 2 branches covered.">    for (Method currentMethod : methods) {</span>
<span class="fc bfc" id="L376" title="All 2 branches covered.">      if (!currentMethod.isBridge()) {</span>
<span class="fc" id="L377">        String signature = getSignature(currentMethod);</span>
        // check to see if the method is already known
        // if it is known, then an extended class must have
        // overridden a method
<span class="fc bfc" id="L381" title="All 2 branches covered.">        if (!uniqueMethods.containsKey(signature)) {</span>
<span class="pc bpc" id="L382" title="1 of 2 branches missed.">          if (canAccessPrivateMethods()) {</span>
            try {
<span class="fc" id="L384">              currentMethod.setAccessible(true);</span>
<span class="fc" id="L385">            } catch (Exception e) {</span>
              // Ignored. This is only a final precaution, nothing we can do.
<span class="fc" id="L387">            }</span>
          }

<span class="fc" id="L390">          uniqueMethods.put(signature, currentMethod);</span>
        }
      }
    }
<span class="fc" id="L394">  }</span>

  /**
   * Gets the signature.
   *
   * @param method
   *          the method
   *
   * @return the signature
   */
  private String getSignature(Method method) {
<span class="fc" id="L405">    StringBuilder sb = new StringBuilder();</span>
<span class="fc" id="L406">    sb.append(method.getName());</span>
<span class="fc" id="L407">    Class[] parameters = method.getParameterTypes();</span>

<span class="fc bfc" id="L409" title="All 2 branches covered.">    for (int i = 0; i &lt; parameters.length; i++) {</span>
<span class="fc bfc" id="L410" title="All 2 branches covered.">      if (i == 0) {</span>
<span class="fc" id="L411">        sb.append(':');</span>
      } else {
<span class="fc" id="L413">        sb.append(',');</span>
      }
<span class="fc" id="L415">      sb.append(parameters[i].getName());</span>
    }

<span class="fc" id="L418">    return sb.toString();</span>
  }

  /**
   * Drop case.
   *
   * @param name
   *          the name
   *
   * @return the string
   */
  private static String dropCase(String name) {
<span class="fc bfc" id="L430" title="All 2 branches covered.">    if (name.startsWith(&quot;is&quot;)) {</span>
<span class="fc" id="L431">      name = name.substring(2);</span>
<span class="pc bpc" id="L432" title="1 of 4 branches missed.">    } else if (name.startsWith(&quot;get&quot;) || name.startsWith(&quot;set&quot;)) {</span>
<span class="fc" id="L433">      name = name.substring(3);</span>
    } else {
<span class="nc" id="L435">      throw new ProbeException(&quot;Error parsing property name '&quot; + name + &quot;'.  Didn't start with 'is', 'get' or 'set'.&quot;);</span>
    }

<span class="pc bpc" id="L438" title="3 of 6 branches missed.">    if (name.length() == 1 || (name.length() &gt; 1 &amp;&amp; !Character.isUpperCase(name.charAt(1)))) {</span>
<span class="fc" id="L439">      name = name.substring(0, 1).toLowerCase(Locale.US) + name.substring(1);</span>
    }

<span class="fc" id="L442">    return name;</span>
  }

  /**
   * Can access private methods.
   *
   * @return true, if successful
   */
  private static boolean canAccessPrivateMethods() {
    try {
<span class="fc" id="L452">      SecurityManager securityManager = System.getSecurityManager();</span>
<span class="pc bpc" id="L453" title="1 of 2 branches missed.">      if (null != securityManager) {</span>
<span class="nc" id="L454">        securityManager.checkPermission(new ReflectPermission(&quot;suppressAccessChecks&quot;));</span>
      }
<span class="nc" id="L456">    } catch (SecurityException e) {</span>
<span class="nc" id="L457">      return false;</span>
<span class="fc" id="L458">    }</span>
<span class="fc" id="L459">    return true;</span>
  }

  /**
   * Gets the name of the class the instance provides information for.
   *
   * @return The class name
   */
  public String getClassName() {
<span class="nc" id="L468">    return className;</span>
  }

  /**
   * Instantiate class.
   *
   * @return the object
   */
  public Object instantiateClass() {
<span class="pc bpc" id="L477" title="1 of 2 branches missed.">    if (defaultConstructor != null) {</span>
      try {
<span class="fc" id="L479">        return defaultConstructor.newInstance();</span>
<span class="nc" id="L480">      } catch (Exception e) {</span>
<span class="nc" id="L481">        throw new RuntimeException(&quot;Error instantiating class. Cause: &quot; + e, e);</span>
      }
    } else {
<span class="nc" id="L484">      throw new RuntimeException(&quot;Error instantiating class.  There is no default constructor for class &quot; + className);</span>
    }
  }

  /**
   * Gets the setter for a property as a Method object.
   *
   * @param propertyName
   *          - the property
   *
   * @return The Method
   */
  public Method getSetter(String propertyName) {
<span class="fc" id="L497">    Invoker method = (Invoker) setMethods.get(propertyName);</span>
<span class="pc bpc" id="L498" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L499">      throw new ProbeException(</span>
          &quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="pc bpc" id="L502" title="1 of 2 branches missed.">    if (!(method instanceof MethodInvoker)) {</span>
<span class="nc" id="L503">      throw new ProbeException(</span>
          &quot;Can't get setter method because '&quot; + propertyName + &quot;' is a field in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L506">    return ((MethodInvoker) method).getMethod();</span>
  }

  /**
   * Gets the getter for a property as a Method object.
   *
   * @param propertyName
   *          - the property
   *
   * @return The Method
   */
  public Method getGetter(String propertyName) {
<span class="fc" id="L518">    Invoker method = (Invoker) getMethods.get(propertyName);</span>
<span class="pc bpc" id="L519" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L520">      throw new ProbeException(</span>
          &quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="pc bpc" id="L523" title="1 of 2 branches missed.">    if (!(method instanceof MethodInvoker)) {</span>
<span class="nc" id="L524">      throw new ProbeException(</span>
          &quot;Can't get getter method because '&quot; + propertyName + &quot;' is a field in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L527">    return ((MethodInvoker) method).getMethod();</span>
  }

  /**
   * Gets the sets the invoker.
   *
   * @param propertyName
   *          the property name
   *
   * @return the sets the invoker
   */
  public Invoker getSetInvoker(String propertyName) {
<span class="fc" id="L539">    Invoker method = (Invoker) setMethods.get(propertyName);</span>
<span class="pc bpc" id="L540" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L541">      throw new ProbeException(</span>
          &quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L544">    return method;</span>
  }

  /**
   * Gets the gets the invoker.
   *
   * @param propertyName
   *          the property name
   *
   * @return the gets the invoker
   */
  public Invoker getGetInvoker(String propertyName) {
<span class="fc" id="L556">    Invoker method = (Invoker) getMethods.get(propertyName);</span>
<span class="pc bpc" id="L557" title="1 of 2 branches missed.">    if (method == null) {</span>
<span class="nc" id="L558">      throw new ProbeException(</span>
          &quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L561">    return method;</span>
  }

  /**
   * Gets the type for a property setter.
   *
   * @param propertyName
   *          - the name of the property
   *
   * @return The Class of the propery setter
   */
  public Class getSetterType(String propertyName) {
<span class="fc" id="L573">    Class clazz = (Class) setTypes.get(propertyName);</span>
<span class="fc bfc" id="L574" title="All 2 branches covered.">    if (clazz == null) {</span>
<span class="fc" id="L575">      throw new ProbeException(</span>
          &quot;There is no WRITEABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L578">    return clazz;</span>
  }

  /**
   * Gets the type for a property getter.
   *
   * @param propertyName
   *          - the name of the property
   *
   * @return The Class of the propery getter
   */
  public Class getGetterType(String propertyName) {
<span class="fc" id="L590">    Class clazz = (Class) getTypes.get(propertyName);</span>
<span class="pc bpc" id="L591" title="1 of 2 branches missed.">    if (clazz == null) {</span>
<span class="nc" id="L592">      throw new ProbeException(</span>
          &quot;There is no READABLE property named '&quot; + propertyName + &quot;' in class '&quot; + className + &quot;'&quot;);
    }
<span class="fc" id="L595">    return clazz;</span>
  }

  /**
   * Gets an array of the readable properties for an object.
   *
   * @return The array
   */
  public String[] getReadablePropertyNames() {
<span class="nc" id="L604">    return readablePropertyNames;</span>
  }

  /**
   * Gets an array of the writeable properties for an object.
   *
   * @return The array
   */
  public String[] getWriteablePropertyNames() {
<span class="fc" id="L613">    return writeablePropertyNames;</span>
  }

  /**
   * Check to see if a class has a writeable property by name.
   *
   * @param propertyName
   *          - the name of the property to check
   *
   * @return True if the object has a writeable property by the name
   */
  public boolean hasWritableProperty(String propertyName) {
<span class="fc" id="L625">    return setMethods.keySet().contains(propertyName);</span>
  }

  /**
   * Check to see if a class has a readable property by name.
   *
   * @param propertyName
   *          - the name of the property to check
   *
   * @return True if the object has a readable property by the name
   */
  public boolean hasReadableProperty(String propertyName) {
<span class="fc" id="L637">    return getMethods.keySet().contains(propertyName);</span>
  }

  /**
   * Tells us if the class passed in is a knwon common type.
   *
   * @param clazz
   *          The class to check
   *
   * @return True if the class is known
   */
  public static boolean isKnownType(Class clazz) {
<span class="pc bpc" id="L649" title="1 of 2 branches missed.">    if (SIMPLE_TYPE_SET.contains(clazz)) {</span>
<span class="nc" id="L650">      return true;</span>
<span class="pc bpc" id="L651" title="1 of 2 branches missed.">    } else if (Collection.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L652">      return true;</span>
<span class="pc bpc" id="L653" title="1 of 2 branches missed.">    } else if (Map.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L654">      return true;</span>
<span class="pc bpc" id="L655" title="1 of 2 branches missed.">    } else if (List.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L656">      return true;</span>
<span class="pc bpc" id="L657" title="1 of 2 branches missed.">    } else if (Set.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L658">      return true;</span>
<span class="pc bpc" id="L659" title="1 of 2 branches missed.">    } else if (Iterator.class.isAssignableFrom(clazz)) {</span>
<span class="nc" id="L660">      return true;</span>
    } else {
<span class="fc" id="L662">      return false;</span>
    }
  }

  /**
   * Gets an instance of ClassInfo for the specified class.
   *
   * @param clazz
   *          The class for which to lookup the method cache.
   *
   * @return The method cache for the class
   */
  public static ClassInfo getInstance(Class clazz) {
<span class="pc bpc" id="L675" title="1 of 2 branches missed.">    if (cacheEnabled) {</span>
<span class="fc" id="L676">      ClassInfo cached = (ClassInfo) CLASS_INFO_MAP.get(clazz);</span>
<span class="fc bfc" id="L677" title="All 2 branches covered.">      if (cached == null) {</span>
<span class="fc" id="L678">        cached = new ClassInfo(clazz);</span>
<span class="fc" id="L679">        CLASS_INFO_MAP.put(clazz, cached);</span>
      }
<span class="fc" id="L681">      return cached;</span>
    } else {
<span class="nc" id="L683">      return new ClassInfo(clazz);</span>
    }
  }

  /**
   * Sets the cache enabled.
   *
   * @param cacheEnabled
   *          the new cache enabled
   */
  public static void setCacheEnabled(boolean cacheEnabled) {
<span class="fc" id="L694">    ClassInfo.cacheEnabled = cacheEnabled;</span>
<span class="fc" id="L695">  }</span>

  /**
   * Examines a Throwable object and gets it's root cause.
   *
   * @param t
   *          - the exception to examine
   *
   * @return The root cause
   */
  public static Throwable unwrapThrowable(Throwable t) {
<span class="fc" id="L706">    Throwable t2 = t;</span>
    while (true) {
<span class="fc bfc" id="L708" title="All 2 branches covered.">      if (t2 instanceof InvocationTargetException) {</span>
<span class="fc" id="L709">        t2 = ((InvocationTargetException) t).getTargetException();</span>
<span class="fc bfc" id="L710" title="All 2 branches covered.">      } else if (t2 instanceof UndeclaredThrowableException) {</span>
<span class="fc" id="L711">        t2 = ((UndeclaredThrowableException) t).getUndeclaredThrowable();</span>
      } else {
<span class="fc" id="L713">        return t2;</span>
      }
    }
  }

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>