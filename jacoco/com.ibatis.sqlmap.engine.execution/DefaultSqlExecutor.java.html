<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultSqlExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.execution</a> &gt; <span class="el_source">DefaultSqlExecutor.java</span></div><h1>DefaultSqlExecutor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.execution;

import com.ibatis.sqlmap.engine.config.SqlMapConfiguration;
import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMap;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMapping;
import com.ibatis.sqlmap.engine.mapping.result.ResultMap;
import com.ibatis.sqlmap.engine.mapping.result.ResultObjectFactoryUtil;
import com.ibatis.sqlmap.engine.mapping.statement.DefaultRowHandler;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;
import com.ibatis.sqlmap.engine.mapping.statement.RowHandlerCallback;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.SessionScope;
import com.ibatis.sqlmap.engine.scope.StatementScope;

import java.sql.BatchUpdateException;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Class responsible for executing the SQL.
 */
<span class="fc" id="L47">public class DefaultSqlExecutor implements SqlExecutor {</span>

  /**
   * Execute an update
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql statement to execute
   * @param parameters
   *          - the parameters for the sql statement
   *
   * @return - the number of records changed
   *
   * @throws SQLException
   *           - if the update fails
   */
  @Override
  public int executeUpdate(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="fc" id="L69">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L70">    errorContext.setActivity(&quot;executing update&quot;);</span>
<span class="fc" id="L71">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L72">    PreparedStatement ps = null;</span>
<span class="fc" id="L73">    setupResultObjectFactory(statementScope);</span>
<span class="fc" id="L74">    int rows = 0;</span>
    try {
<span class="fc" id="L76">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L77">      ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
<span class="fc" id="L78">      setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L79">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L80">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L81">      errorContext.setMoreInfo(&quot;Check the statement (update failed).&quot;);</span>
<span class="fc" id="L82">      ps.execute();</span>
<span class="fc" id="L83">      rows = ps.getUpdateCount();</span>
    } finally {
<span class="fc" id="L85">      closeStatement(statementScope.getSession(), ps);</span>
<span class="fc" id="L86">      cleanupResultObjectFactory();</span>
    }
<span class="fc" id="L88">    return rows;</span>
  }

  /**
   * Adds a statement to a batch
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql statement
   * @param parameters
   *          - the parameters for the statement
   *
   * @throws SQLException
   *           - if the statement fails
   */
  @Override
  public void addBatch(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="fc" id="L109">    Batch batch = (Batch) statementScope.getSession().getBatch();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (batch == null) {</span>
<span class="fc" id="L111">      batch = new Batch();</span>
<span class="fc" id="L112">      statementScope.getSession().setBatch(batch);</span>
    }
<span class="fc" id="L114">    batch.addBatch(statementScope, conn, sql, parameters);</span>
<span class="fc" id="L115">  }</span>

  /**
   * Execute a batch of statements
   *
   * @param sessionScope
   *          - the session scope
   *
   * @return - the number of rows impacted by the batch
   *
   * @throws SQLException
   *           - if a statement fails
   */
  @Override
  public int executeBatch(SessionScope sessionScope) throws SQLException {
<span class="fc" id="L130">    int rows = 0;</span>
<span class="fc" id="L131">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">    if (batch != null) {</span>
      try {
<span class="fc" id="L134">        rows = batch.executeBatch();</span>
      } finally {
<span class="fc" id="L136">        batch.cleanupBatch(sessionScope);</span>
      }
    }
<span class="fc" id="L139">    return rows;</span>
  }

  /**
   * Execute a batch of statements
   *
   * @param sessionScope
   *          - the session scope
   *
   * @return - a List of BatchResult objects (may be null if no batch has been initiated). There will be one BatchResult
   *         object in the list for each sub-batch executed
   *
   * @throws SQLException
   *           if a database access error occurs, or the drive does not support batch statements
   * @throws BatchException
   *           if the driver throws BatchUpdateException
   */
  @Override
  public List executeBatchDetailed(SessionScope sessionScope) throws SQLException, BatchException {
<span class="fc" id="L158">    List answer = null;</span>
<span class="fc" id="L159">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (batch != null) {</span>
      try {
<span class="fc" id="L162">        answer = batch.executeBatchDetailed();</span>
      } finally {
<span class="fc" id="L164">        batch.cleanupBatch(sessionScope);</span>
      }
    }
<span class="fc" id="L167">    return answer;</span>
  }

  /**
   * Long form of the method to execute a query
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the SQL statement to execute
   * @param parameters
   *          - the parameters for the statement
   * @param skipResults
   *          - the number of results to skip
   * @param maxResults
   *          - the maximum number of results to return
   * @param callback
   *          - the row handler for the query
   *
   * @throws SQLException
   *           - if the query fails
   */
  @Override
  public void executeQuery(StatementScope statementScope, Connection conn, String sql, Object[] parameters,
      int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L194">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L195">    errorContext.setActivity(&quot;executing query&quot;);</span>
<span class="fc" id="L196">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L197">    PreparedStatement ps = null;</span>
<span class="fc" id="L198">    ResultSet rs = null;</span>
<span class="fc" id="L199">    setupResultObjectFactory(statementScope);</span>
    try {
<span class="fc" id="L201">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L202">      Integer rsType = statementScope.getStatement().getResultSetType();</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">      if (rsType != null) {</span>
<span class="nc" id="L204">        ps = prepareStatement(statementScope.getSession(), conn, sql, rsType);</span>
      } else {
<span class="fc" id="L206">        ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
      }
<span class="fc" id="L208">      setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L209">      Integer fetchSize = statementScope.getStatement().getFetchSize();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">      if (fetchSize != null) {</span>
<span class="nc" id="L211">        ps.setFetchSize(fetchSize.intValue());</span>
      }
<span class="fc" id="L213">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L214">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L215">      errorContext.setMoreInfo(&quot;Check the statement (query failed).&quot;);</span>
<span class="fc" id="L216">      ps.execute();</span>
<span class="fc" id="L217">      errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);</span>

      // Begin ResultSet Handling
<span class="fc" id="L220">      rs = handleMultipleResults(ps, statementScope, skipResults, maxResults, callback);</span>
      // End ResultSet Handling
    } finally {
      try {
<span class="fc" id="L224">        closeResultSet(rs);</span>
      } finally {
<span class="fc" id="L226">        closeStatement(statementScope.getSession(), ps);</span>
<span class="fc" id="L227">        cleanupResultObjectFactory();</span>
      }
    }

<span class="fc" id="L231">  }</span>

  /**
   * Execute a stored procedure that updates data
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the SQL to call the procedure
   * @param parameters
   *          - the parameters for the procedure
   *
   * @return - the rows impacted by the procedure
   *
   * @throws SQLException
   *           - if the procedure fails
   */
  @Override
  public int executeUpdateProcedure(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="nc" id="L253">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="nc" id="L254">    errorContext.setActivity(&quot;executing update procedure&quot;);</span>
<span class="nc" id="L255">    errorContext.setObjectId(sql);</span>
<span class="nc" id="L256">    CallableStatement cs = null;</span>
<span class="nc" id="L257">    setupResultObjectFactory(statementScope);</span>
<span class="nc" id="L258">    int rows = 0;</span>
    try {
<span class="nc" id="L260">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="nc" id="L261">      cs = prepareCall(statementScope.getSession(), conn, sql);</span>
<span class="nc" id="L262">      setStatementTimeout(statementScope.getStatement(), cs);</span>
<span class="nc" id="L263">      ParameterMap parameterMap = statementScope.getParameterMap();</span>
<span class="nc" id="L264">      ParameterMapping[] mappings = parameterMap.getParameterMappings();</span>
<span class="nc" id="L265">      errorContext.setMoreInfo(&quot;Check the output parameters (register output parameters failed).&quot;);</span>
<span class="nc" id="L266">      registerOutputParameters(cs, mappings);</span>
<span class="nc" id="L267">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="nc" id="L268">      parameterMap.setParameters(statementScope, cs, parameters);</span>
<span class="nc" id="L269">      errorContext.setMoreInfo(&quot;Check the statement (update procedure failed).&quot;);</span>
<span class="nc" id="L270">      cs.execute();</span>
<span class="nc" id="L271">      rows = cs.getUpdateCount();</span>
<span class="nc" id="L272">      errorContext.setMoreInfo(&quot;Check the output parameters (retrieval of output parameters failed).&quot;);</span>
<span class="nc" id="L273">      retrieveOutputParameters(statementScope, cs, mappings, parameters, null);</span>
    } finally {
<span class="nc" id="L275">      closeStatement(statementScope.getSession(), cs);</span>
<span class="nc" id="L276">      cleanupResultObjectFactory();</span>
    }
<span class="nc" id="L278">    return rows;</span>
  }

  /**
   * Execute a stored procedure
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql to call the procedure
   * @param parameters
   *          - the parameters for the procedure
   * @param skipResults
   *          - the number of results to skip
   * @param maxResults
   *          - the maximum number of results to return
   * @param callback
   *          - a row handler for processing the results
   *
   * @throws SQLException
   *           - if the procedure fails
   */
  @Override
  public void executeQueryProcedure(StatementScope statementScope, Connection conn, String sql, Object[] parameters,
      int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L305">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L306">    errorContext.setActivity(&quot;executing query procedure&quot;);</span>
<span class="fc" id="L307">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L308">    CallableStatement cs = null;</span>
<span class="fc" id="L309">    ResultSet rs = null;</span>
<span class="fc" id="L310">    setupResultObjectFactory(statementScope);</span>
    try {
<span class="fc" id="L312">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L313">      Integer rsType = statementScope.getStatement().getResultSetType();</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">      if (rsType != null) {</span>
<span class="nc" id="L315">        cs = prepareCall(statementScope.getSession(), conn, sql, rsType);</span>
      } else {
<span class="fc" id="L317">        cs = prepareCall(statementScope.getSession(), conn, sql);</span>
      }
<span class="fc" id="L319">      setStatementTimeout(statementScope.getStatement(), cs);</span>
<span class="fc" id="L320">      Integer fetchSize = statementScope.getStatement().getFetchSize();</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">      if (fetchSize != null) {</span>
<span class="nc" id="L322">        cs.setFetchSize(fetchSize.intValue());</span>
      }
<span class="fc" id="L324">      ParameterMap parameterMap = statementScope.getParameterMap();</span>
<span class="fc" id="L325">      ParameterMapping[] mappings = parameterMap.getParameterMappings();</span>
<span class="fc" id="L326">      errorContext.setMoreInfo(&quot;Check the output parameters (register output parameters failed).&quot;);</span>
<span class="fc" id="L327">      registerOutputParameters(cs, mappings);</span>
<span class="fc" id="L328">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L329">      parameterMap.setParameters(statementScope, cs, parameters);</span>
<span class="fc" id="L330">      errorContext.setMoreInfo(&quot;Check the statement (update procedure failed).&quot;);</span>
<span class="fc" id="L331">      cs.execute();</span>
<span class="fc" id="L332">      errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);</span>

      // Begin ResultSet Handling
<span class="fc" id="L335">      rs = handleMultipleResults(cs, statementScope, skipResults, maxResults, callback);</span>
      // End ResultSet Handling
<span class="fc" id="L337">      errorContext.setMoreInfo(&quot;Check the output parameters (retrieval of output parameters failed).&quot;);</span>
<span class="fc" id="L338">      retrieveOutputParameters(statementScope, cs, mappings, parameters, callback);</span>

    } finally {
      try {
<span class="fc" id="L342">        closeResultSet(rs);</span>
      } finally {
<span class="fc" id="L344">        closeStatement(statementScope.getSession(), cs);</span>
<span class="fc" id="L345">        cleanupResultObjectFactory();</span>
      }
    }
<span class="fc" id="L348">  }</span>

  @Override
  public void init(SqlMapConfiguration config, Properties globalProps) {
    // No implementation is required in DefaultSqlExecutor.
<span class="nc" id="L353">  }</span>

  /**
   * Handle multiple results.
   *
   * @param ps
   *          the ps
   * @param statementScope
   *          the statement scope
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   * @param callback
   *          the callback
   *
   * @return the result set
   *
   * @throws SQLException
   *           the SQL exception
   */
  private ResultSet handleMultipleResults(PreparedStatement ps, StatementScope statementScope, int skipResults,
      int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L376">    ResultSet rs = getFirstResultSet(statementScope, ps);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">    if (rs != null) {</span>
<span class="fc" id="L378">      handleResults(statementScope, rs, skipResults, maxResults, callback);</span>
    }

    // Multiple ResultSet handling
<span class="fc bfc" id="L382" title="All 2 branches covered.">    if (callback.getRowHandler() instanceof DefaultRowHandler) {</span>
<span class="fc" id="L383">      MappedStatement statement = statementScope.getStatement();</span>
<span class="fc" id="L384">      DefaultRowHandler defaultRowHandler = (DefaultRowHandler) callback.getRowHandler();</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">      if (statement.hasMultipleResultMaps()) {</span>
<span class="fc" id="L386">        List multipleResults = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L387">        multipleResults.add(defaultRowHandler.getList());</span>
<span class="fc" id="L388">        ResultMap[] resultMaps = statement.getAdditionalResultMaps();</span>
<span class="fc" id="L389">        int i = 0;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        while (moveToNextResultsSafely(statementScope, ps)) {</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">          if (i &gt;= resultMaps.length) {</span>
<span class="nc" id="L392">            break;</span>
          }
<span class="fc" id="L394">          ResultMap rm = resultMaps[i];</span>
<span class="fc" id="L395">          statementScope.setResultMap(rm);</span>
<span class="fc" id="L396">          rs = ps.getResultSet();</span>
<span class="fc" id="L397">          DefaultRowHandler rh = new DefaultRowHandler();</span>
<span class="fc" id="L398">          handleResults(statementScope, rs, skipResults, maxResults, new RowHandlerCallback(rm, null, rh));</span>
<span class="fc" id="L399">          multipleResults.add(rh.getList());</span>
<span class="fc" id="L400">          i++;</span>
<span class="fc" id="L401">        }</span>
<span class="fc" id="L402">        defaultRowHandler.setList(multipleResults);</span>
<span class="fc" id="L403">        statementScope.setResultMap(statement.getResultMap());</span>
<span class="fc" id="L404">      } else {</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        while (moveToNextResultsSafely(statementScope, ps)) {</span>
          ;
        }
      }
    }
    // End additional ResultSet handling
<span class="fc" id="L411">    return rs;</span>
  }

  /**
   * Gets the first result set.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return the first result set
   *
   * @throws SQLException
   *           the SQL exception
   */
  private ResultSet getFirstResultSet(StatementScope scope, Statement stmt) throws SQLException {
<span class="fc" id="L428">    ResultSet rs = null;</span>
<span class="fc" id="L429">    boolean hasMoreResults = true;</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">    while (hasMoreResults) {</span>
<span class="fc" id="L431">      rs = stmt.getResultSet();</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">      if (rs != null) {</span>
<span class="fc" id="L433">        break;</span>
      }
<span class="nc" id="L435">      hasMoreResults = moveToNextResultsIfPresent(scope, stmt);</span>
    }
<span class="fc" id="L437">    return rs;</span>
  }

  /**
   * Move to next results if present.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if successful
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean moveToNextResultsIfPresent(StatementScope scope, Statement stmt) throws SQLException {
    boolean moreResults;
    // This is the messed up JDBC approach for determining if there are more results
<span class="nc" id="L456">    boolean movedToNextResultsSafely = moveToNextResultsSafely(scope, stmt);</span>
<span class="nc" id="L457">    int updateCount = stmt.getUpdateCount();</span>

<span class="nc bnc" id="L459" title="All 4 branches missed.">    moreResults = movedToNextResultsSafely || updateCount != -1;</span>

    // ibatis-384: workaround for mysql not returning -1 for stmt.getUpdateCount()
<span class="nc bnc" id="L462" title="All 2 branches missed.">    if (moreResults) {</span>
<span class="nc bnc" id="L463" title="All 4 branches missed.">      moreResults = movedToNextResultsSafely || isMultipleResultSetSupportPresent(scope, stmt);</span>
    }

<span class="nc" id="L466">    return moreResults;</span>
  }

  /**
   * Move to next results safely.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if successful
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean moveToNextResultsSafely(StatementScope scope, Statement stmt) throws SQLException {
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">    if (isMultipleResultSetSupportPresent(scope, stmt)) {</span>
<span class="fc" id="L484">      return stmt.getMoreResults();</span>
    }
<span class="nc" id="L486">    return false;</span>
  }

  /**
   * checks whether multiple result set support is present - either by direct support of the database driver or by
   * forcing it.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if is multiple result set support present
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean isMultipleResultSetSupportPresent(StatementScope scope, Statement stmt) throws SQLException {
<span class="pc bpc" id="L504" title="2 of 4 branches missed.">    return forceMultipleResultSetSupport(scope) || stmt.getConnection().getMetaData().supportsMultipleResultSets();</span>
  }

  /**
   * Force multiple result set support.
   *
   * @param scope
   *          the scope
   *
   * @return true, if successful
   */
  private boolean forceMultipleResultSetSupport(StatementScope scope) {
<span class="fc" id="L516">    return ((SqlMapClientImpl) scope.getSession().getSqlMapClient()).getDelegate().isForceMultipleResultSetSupport();</span>
  }

  /**
   * Handle results.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void handleResults(StatementScope statementScope, ResultSet rs, int skipResults, int maxResults,
      RowHandlerCallback callback) throws SQLException {
    try {
<span class="fc" id="L539">      statementScope.setResultSet(rs);</span>
<span class="fc" id="L540">      ResultMap resultMap = statementScope.getResultMap();</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">      if (resultMap != null) {</span>
        // Skip Results
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">          if (skipResults &gt; 0) {</span>
<span class="nc" id="L545">            rs.absolute(skipResults);</span>
          }
        } else {
<span class="fc bfc" id="L548" title="All 2 branches covered.">          for (int i = 0; i &lt; skipResults; i++) {</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">            if (!rs.next()) {</span>
<span class="fc" id="L550">              return;</span>
            }
          }
        }

        // Get Results
<span class="fc" id="L556">        int resultsFetched = 0;</span>
<span class="fc bfc" id="L557" title="All 6 branches covered.">        while ((maxResults == NO_MAXIMUM_RESULTS || resultsFetched &lt; maxResults) &amp;&amp; rs.next()) {</span>
<span class="fc" id="L558">          Object[] columnValues = resultMap.resolveSubMap(statementScope, rs).getResults(statementScope, rs);</span>
<span class="fc" id="L559">          callback.handleResultObject(statementScope, columnValues, rs);</span>
<span class="fc" id="L560">          resultsFetched++;</span>
<span class="fc" id="L561">        }</span>
      }
    } finally {
<span class="fc" id="L564">      statementScope.setResultSet(null);</span>
    }
<span class="fc" id="L566">  }</span>

  /**
   * Retrieve output parameters.
   *
   * @param statementScope
   *          the statement scope
   * @param cs
   *          the cs
   * @param mappings
   *          the mappings
   * @param parameters
   *          the parameters
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void retrieveOutputParameters(StatementScope statementScope, CallableStatement cs,
      ParameterMapping[] mappings, Object[] parameters, RowHandlerCallback callback) throws SQLException {
<span class="fc bfc" id="L587" title="All 2 branches covered.">    for (int i = 0; i &lt; mappings.length; i++) {</span>
<span class="fc" id="L588">      ParameterMapping mapping = mappings[i];</span>
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">      if (mapping.isOutputAllowed()) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (&quot;java.sql.ResultSet&quot;.equalsIgnoreCase(mapping.getJavaTypeName())) {</span>
<span class="nc" id="L591">          ResultSet rs = (ResultSet) cs.getObject(i + 1);</span>
          ResultMap resultMap;
<span class="nc bnc" id="L593" title="All 2 branches missed.">          if (mapping.getResultMapName() == null) {</span>
<span class="nc" id="L594">            resultMap = statementScope.getResultMap();</span>
<span class="nc" id="L595">            handleOutputParameterResults(statementScope, resultMap, rs, callback);</span>
          } else {
<span class="nc" id="L597">            SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="nc" id="L598">            resultMap = client.getDelegate().getResultMap(mapping.getResultMapName());</span>
<span class="nc" id="L599">            DefaultRowHandler rowHandler = new DefaultRowHandler();</span>
<span class="nc" id="L600">            RowHandlerCallback handlerCallback = new RowHandlerCallback(resultMap, null, rowHandler);</span>
<span class="nc" id="L601">            handleOutputParameterResults(statementScope, resultMap, rs, handlerCallback);</span>
<span class="nc" id="L602">            parameters[i] = rowHandler.getList();</span>
          }
<span class="nc" id="L604">          rs.close();</span>
<span class="nc" id="L605">        } else {</span>
<span class="nc" id="L606">          parameters[i] = mapping.getTypeHandler().getResult(cs, i + 1);</span>
        }
      }
    }
<span class="fc" id="L610">  }</span>

  /**
   * Register output parameters.
   *
   * @param cs
   *          the cs
   * @param mappings
   *          the mappings
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void registerOutputParameters(CallableStatement cs, ParameterMapping[] mappings) throws SQLException {
<span class="fc bfc" id="L624" title="All 2 branches covered.">    for (int i = 0; i &lt; mappings.length; i++) {</span>
<span class="fc" id="L625">      ParameterMapping mapping = mappings[i];</span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">      if (mapping.isOutputAllowed()) {</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">        if (null != mapping.getTypeName() &amp;&amp; !mapping.getTypeName().equals(&quot;&quot;)) { // @added</span>
<span class="nc" id="L628">          cs.registerOutParameter(i + 1, mapping.getJdbcType(), mapping.getTypeName());</span>
<span class="nc bnc" id="L629" title="All 2 branches missed.">        } else if (mapping.getNumericScale() != null</span>
<span class="nc bnc" id="L630" title="All 4 branches missed.">            &amp;&amp; (mapping.getJdbcType() == Types.NUMERIC || mapping.getJdbcType() == Types.DECIMAL)) {</span>
<span class="nc" id="L631">          cs.registerOutParameter(i + 1, mapping.getJdbcType(), mapping.getNumericScale().intValue());</span>
        } else {
<span class="nc" id="L633">          cs.registerOutParameter(i + 1, mapping.getJdbcType());</span>
        }
      }
    }
<span class="fc" id="L637">  }</span>

  /**
   * Handle output parameter results.
   *
   * @param statementScope
   *          the statement scope
   * @param resultMap
   *          the result map
   * @param rs
   *          the rs
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void handleOutputParameterResults(StatementScope statementScope, ResultMap resultMap, ResultSet rs,
      RowHandlerCallback callback) throws SQLException {
<span class="nc" id="L656">    ResultMap orig = statementScope.getResultMap();</span>
    try {
<span class="nc" id="L658">      statementScope.setResultSet(rs);</span>
<span class="nc bnc" id="L659" title="All 2 branches missed.">      if (resultMap != null) {</span>
<span class="nc" id="L660">        statementScope.setResultMap(resultMap);</span>

        // Get Results
<span class="nc bnc" id="L663" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L664">          Object[] columnValues = resultMap.resolveSubMap(statementScope, rs).getResults(statementScope, rs);</span>
<span class="nc" id="L665">          callback.handleResultObject(statementScope, columnValues, rs);</span>
<span class="nc" id="L666">        }</span>
      }
    } finally {
<span class="nc" id="L669">      statementScope.setResultSet(null);</span>
<span class="nc" id="L670">      statementScope.setResultMap(orig);</span>
    }
<span class="nc" id="L672">  }</span>

  /**
   * Clean up any batches on the session
   *
   * @param sessionScope
   *          - the session to clean up
   */
  @Override
  public void cleanup(SessionScope sessionScope) {
<span class="fc" id="L682">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="fc bfc" id="L683" title="All 2 branches covered.">    if (batch != null) {</span>
<span class="fc" id="L684">      batch.cleanupBatch(sessionScope);</span>
<span class="fc" id="L685">      sessionScope.setBatch(null);</span>
    }
<span class="fc" id="L687">  }</span>

  /**
   * Prepare statement.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   * @param rsType
   *          the rs type
   *
   * @return the prepared statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private PreparedStatement prepareStatement(SessionScope sessionScope, Connection conn, String sql, Integer rsType)
      throws SQLException {
<span class="nc" id="L708">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="nc bnc" id="L709" title="All 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L710">      return sessionScope.getPreparedStatement(sql);</span>
    }
<span class="nc" id="L712">    PreparedStatement ps = conn.prepareStatement(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);</span>
<span class="nc" id="L713">    sessionScope.putPreparedStatement(delegate, sql, ps);</span>
<span class="nc" id="L714">    return ps;</span>
  }

  /**
   * Prepare call.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   * @param rsType
   *          the rs type
   *
   * @return the callable statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private CallableStatement prepareCall(SessionScope sessionScope, Connection conn, String sql, Integer rsType)
      throws SQLException {
<span class="nc" id="L736">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="nc bnc" id="L737" title="All 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L738">      return (CallableStatement) sessionScope.getPreparedStatement(sql);</span>
    }
<span class="nc" id="L740">    CallableStatement cs = conn.prepareCall(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);</span>
<span class="nc" id="L741">    sessionScope.putPreparedStatement(delegate, sql, cs);</span>
<span class="nc" id="L742">    return cs;</span>
  }

  /**
   * Prepare statement.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   *
   * @return the prepared statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private static PreparedStatement prepareStatement(SessionScope sessionScope, Connection conn, String sql)
      throws SQLException {
<span class="fc" id="L762">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="fc bfc" id="L763" title="All 2 branches covered.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="fc" id="L764">      return sessionScope.getPreparedStatement(sql);</span>
    }
<span class="fc" id="L766">    PreparedStatement ps = conn.prepareStatement(sql);</span>
<span class="fc" id="L767">    sessionScope.putPreparedStatement(delegate, sql, ps);</span>
<span class="fc" id="L768">    return ps;</span>
  }

  /**
   * Prepare call.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   *
   * @return the callable statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private CallableStatement prepareCall(SessionScope sessionScope, Connection conn, String sql) throws SQLException {
<span class="fc" id="L787">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="pc bpc" id="L788" title="1 of 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L789">      return (CallableStatement) sessionScope.getPreparedStatement(sql);</span>
    }
<span class="fc" id="L791">    CallableStatement cs = conn.prepareCall(sql);</span>
<span class="fc" id="L792">    sessionScope.putPreparedStatement(delegate, sql, cs);</span>
<span class="fc" id="L793">    return cs;</span>
  }

  /**
   * Close statement.
   *
   * @param sessionScope
   *          the session scope
   * @param ps
   *          the ps
   */
  private static void closeStatement(SessionScope sessionScope, PreparedStatement ps) {
<span class="fc bfc" id="L805" title="All 4 branches covered.">    if (ps != null &amp;&amp; !sessionScope.hasPreparedStatement(ps)) {</span>
      try {
<span class="fc" id="L807">        ps.close();</span>
<span class="nc" id="L808">      } catch (SQLException e) {</span>
        // ignore
<span class="fc" id="L810">      }</span>
    }
<span class="fc" id="L812">  }</span>

  /**
   * Close result set.
   *
   * @param rs
   *          the rs
   */
  private static void closeResultSet(ResultSet rs) {
<span class="fc bfc" id="L821" title="All 2 branches covered.">    if (rs != null) {</span>
      try {
<span class="fc" id="L823">        rs.close();</span>
<span class="nc" id="L824">      } catch (SQLException e) {</span>
        // ignore
<span class="fc" id="L826">      }</span>
    }
<span class="fc" id="L828">  }</span>

  /**
   * Sets the statement timeout.
   *
   * @param mappedStatement
   *          the mapped statement
   * @param statement
   *          the statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private static void setStatementTimeout(MappedStatement mappedStatement, Statement statement) throws SQLException {
<span class="pc bpc" id="L842" title="1 of 2 branches missed.">    if (mappedStatement.getTimeout() != null) {</span>
<span class="nc" id="L843">      statement.setQueryTimeout(mappedStatement.getTimeout().intValue());</span>
    }
<span class="fc" id="L845">  }</span>

  /**
   * The Class Batch.
   */
  private static class Batch {

    /** The current sql. */
    private String currentSql;

    /** The statement list. */
<span class="fc" id="L856">    private List statementList = new ArrayList&lt;&gt;();</span>

    /** The batch result list. */
<span class="fc" id="L859">    private List batchResultList = new ArrayList&lt;&gt;();</span>

    /** The size. */
    private int size;

    /**
     * Create a new batch.
     */
<span class="fc" id="L867">    public Batch() {</span>
<span class="fc" id="L868">      this.size = 0;</span>
<span class="fc" id="L869">    }</span>

    /**
     * Getter for the batch size.
     *
     * @return - the batch size
     */
    public int getSize() {
<span class="nc" id="L877">      return size;</span>
    }

    /**
     * Add a prepared statement to the batch.
     *
     * @param statementScope
     *          - the request scope
     * @param conn
     *          - the database connection
     * @param sql
     *          - the SQL to add
     * @param parameters
     *          - the parameters for the SQL
     *
     * @throws SQLException
     *           - if the prepare for the SQL fails
     */
    public void addBatch(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
        throws SQLException {
<span class="fc" id="L897">      PreparedStatement ps = null;</span>
<span class="fc bfc" id="L898" title="All 4 branches covered.">      if (currentSql != null &amp;&amp; currentSql.equals(sql)) {</span>
<span class="fc" id="L899">        int last = statementList.size() - 1;</span>
<span class="fc" id="L900">        ps = (PreparedStatement) statementList.get(last);</span>
<span class="fc" id="L901">      } else {</span>
<span class="fc" id="L902">        ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
<span class="fc" id="L903">        setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L904">        currentSql = sql;</span>
<span class="fc" id="L905">        statementList.add(ps);</span>
<span class="fc" id="L906">        batchResultList.add(new BatchResult(statementScope.getStatement().getId(), sql));</span>
      }
<span class="fc" id="L908">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L909">      ps.addBatch();</span>
<span class="fc" id="L910">      size++;</span>
<span class="fc" id="L911">    }</span>

    /**
     * TODO (Jeff Butler) - maybe this method should be deprecated in some release, and then removed in some even later
     * release. executeBatchDetailed gives much more complete information.
     * &lt;p&gt;
     * Execute the current session's batch
     *
     * @return - the number of rows updated
     *
     * @throws SQLException
     *           - if the batch fails
     */
    public int executeBatch() throws SQLException {
<span class="fc" id="L925">      int totalRowCount = 0;</span>
<span class="fc bfc" id="L926" title="All 2 branches covered.">      for (Object element : statementList) {</span>
<span class="fc" id="L927">        PreparedStatement ps = (PreparedStatement) element;</span>
<span class="fc" id="L928">        int[] rowCounts = ps.executeBatch();</span>
<span class="fc bfc" id="L929" title="All 2 branches covered.">        for (int j = 0; j &lt; rowCounts.length; j++) {</span>
<span class="pc bpc" id="L930" title="1 of 2 branches missed.">          if (rowCounts[j] == Statement.SUCCESS_NO_INFO) {</span>
            // do nothing
<span class="pc bpc" id="L932" title="1 of 2 branches missed.">          } else if (rowCounts[j] == Statement.EXECUTE_FAILED) {</span>
<span class="nc" id="L933">            throw new SQLException(&quot;The batched statement at index &quot; + j + &quot; failed to execute.&quot;);</span>
          } else {
<span class="fc" id="L935">            totalRowCount += rowCounts[j];</span>
          }
        }
<span class="fc" id="L938">      }</span>
<span class="fc" id="L939">      return totalRowCount;</span>
    }

    /**
     * Batch execution method that returns all the information the driver has to offer.
     *
     * @return a List of BatchResult objects
     *
     * @throws SQLException
     *           if a database access error occurs, or the drive does not support batch statements
     * @throws BatchException
     *           if the driver throws BatchUpdateException
     */
    public List executeBatchDetailed() throws SQLException, BatchException {
<span class="fc" id="L953">      List answer = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L954" title="All 2 branches covered.">      for (int i = 0, n = statementList.size(); i &lt; n; i++) {</span>
<span class="fc" id="L955">        BatchResult br = (BatchResult) batchResultList.get(i);</span>
<span class="fc" id="L956">        PreparedStatement ps = (PreparedStatement) statementList.get(i);</span>
        try {
<span class="fc" id="L958">          br.setUpdateCounts(ps.executeBatch());</span>
<span class="fc" id="L959">        } catch (BatchUpdateException e) {</span>
<span class="fc" id="L960">          StringBuilder message = new StringBuilder();</span>
<span class="fc" id="L961">          message.append(&quot;Sub batch number &quot;);</span>
<span class="fc" id="L962">          message.append(i + 1);</span>
<span class="fc" id="L963">          message.append(&quot; failed.&quot;);</span>
<span class="pc bpc" id="L964" title="1 of 2 branches missed.">          if (i &gt; 0) {</span>
<span class="fc" id="L965">            message.append(&quot; &quot;);</span>
<span class="fc" id="L966">            message.append(i);</span>
<span class="fc" id="L967">            message.append(&quot; prior sub batch(s) completed successfully, but will be rolled back.&quot;);</span>
          }
<span class="fc" id="L969">          throw new BatchException(message.toString(), e, answer, br.getStatementId(), br.getSql());</span>
<span class="fc" id="L970">        }</span>
<span class="fc" id="L971">        answer.add(br);</span>
      }
<span class="fc" id="L973">      return answer;</span>
    }

    /**
     * Close all the statements in the batch and clear all the statements.
     *
     * @param sessionScope
     *          the session scope
     */
    public void cleanupBatch(SessionScope sessionScope) {
<span class="fc bfc" id="L983" title="All 2 branches covered.">      for (Object element : statementList) {</span>
<span class="fc" id="L984">        PreparedStatement ps = (PreparedStatement) element;</span>
<span class="fc" id="L985">        closeStatement(sessionScope, ps);</span>
<span class="fc" id="L986">      }</span>
<span class="fc" id="L987">      currentSql = null;</span>
<span class="fc" id="L988">      statementList.clear();</span>
<span class="fc" id="L989">      batchResultList.clear();</span>
<span class="fc" id="L990">      size = 0;</span>
<span class="fc" id="L991">    }</span>
  }

  /**
   * Sets the up result object factory.
   *
   * @param statementScope
   *          the new up result object factory
   */
  private void setupResultObjectFactory(StatementScope statementScope) {
<span class="fc" id="L1001">    SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="fc" id="L1002">    ResultObjectFactoryUtil.setupResultObjectFactory(client.getResultObjectFactory(),</span>
<span class="fc" id="L1003">        statementScope.getStatement().getId());</span>
<span class="fc" id="L1004">  }</span>

  /**
   * Cleanup result object factory.
   */
  private void cleanupResultObjectFactory() {
<span class="fc" id="L1010">    ResultObjectFactoryUtil.cleanupResultObjectFactory();</span>
<span class="fc" id="L1011">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>