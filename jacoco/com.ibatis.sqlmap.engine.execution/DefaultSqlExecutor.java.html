<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultSqlExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.execution</a> &gt; <span class="el_source">DefaultSqlExecutor.java</span></div><h1>DefaultSqlExecutor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.execution;

import com.ibatis.sqlmap.engine.config.SqlMapConfiguration;
import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMap;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMapping;
import com.ibatis.sqlmap.engine.mapping.result.ResultMap;
import com.ibatis.sqlmap.engine.mapping.result.ResultObjectFactoryUtil;
import com.ibatis.sqlmap.engine.mapping.statement.DefaultRowHandler;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;
import com.ibatis.sqlmap.engine.mapping.statement.RowHandlerCallback;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.SessionScope;
import com.ibatis.sqlmap.engine.scope.StatementScope;

import java.sql.BatchUpdateException;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Class responsible for executing the SQL.
 */
<span class="fc" id="L47">public class DefaultSqlExecutor implements SqlExecutor {</span>

  //
  // Public Methods
  //

  /**
   * Execute an update
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql statement to execute
   * @param parameters
   *          - the parameters for the sql statement
   *
   * @return - the number of records changed
   *
   * @throws SQLException
   *           - if the update fails
   */
  public int executeUpdate(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="fc" id="L72">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L73">    errorContext.setActivity(&quot;executing update&quot;);</span>
<span class="fc" id="L74">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L75">    PreparedStatement ps = null;</span>
<span class="fc" id="L76">    setupResultObjectFactory(statementScope);</span>
<span class="fc" id="L77">    int rows = 0;</span>
    try {
<span class="fc" id="L79">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L80">      ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
<span class="fc" id="L81">      setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L82">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L83">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L84">      errorContext.setMoreInfo(&quot;Check the statement (update failed).&quot;);</span>
<span class="fc" id="L85">      ps.execute();</span>
<span class="fc" id="L86">      rows = ps.getUpdateCount();</span>
    } finally {
<span class="fc" id="L88">      closeStatement(statementScope.getSession(), ps);</span>
<span class="fc" id="L89">      cleanupResultObjectFactory();</span>
    }
<span class="fc" id="L91">    return rows;</span>
  }

  /**
   * Adds a statement to a batch
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql statement
   * @param parameters
   *          - the parameters for the statement
   *
   * @throws SQLException
   *           - if the statement fails
   */
  public void addBatch(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="fc" id="L111">    Batch batch = (Batch) statementScope.getSession().getBatch();</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (batch == null) {</span>
<span class="fc" id="L113">      batch = new Batch();</span>
<span class="fc" id="L114">      statementScope.getSession().setBatch(batch);</span>
    }
<span class="fc" id="L116">    batch.addBatch(statementScope, conn, sql, parameters);</span>
<span class="fc" id="L117">  }</span>

  /**
   * Execute a batch of statements
   *
   * @param sessionScope
   *          - the session scope
   *
   * @return - the number of rows impacted by the batch
   *
   * @throws SQLException
   *           - if a statement fails
   */
  public int executeBatch(SessionScope sessionScope) throws SQLException {
<span class="fc" id="L131">    int rows = 0;</span>
<span class="fc" id="L132">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="fc bfc" id="L133" title="All 2 branches covered.">    if (batch != null) {</span>
      try {
<span class="fc" id="L135">        rows = batch.executeBatch();</span>
      } finally {
<span class="fc" id="L137">        batch.cleanupBatch(sessionScope);</span>
      }
    }
<span class="fc" id="L140">    return rows;</span>
  }

  /**
   * Execute a batch of statements
   *
   * @param sessionScope
   *          - the session scope
   *
   * @return - a List of BatchResult objects (may be null if no batch has been initiated). There will be one BatchResult
   *         object in the list for each sub-batch executed
   *
   * @throws SQLException
   *           if a database access error occurs, or the drive does not support batch statements
   * @throws BatchException
   *           if the driver throws BatchUpdateException
   */
  public List executeBatchDetailed(SessionScope sessionScope) throws SQLException, BatchException {
<span class="fc" id="L158">    List answer = null;</span>
<span class="fc" id="L159">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (batch != null) {</span>
      try {
<span class="fc" id="L162">        answer = batch.executeBatchDetailed();</span>
      } finally {
<span class="fc" id="L164">        batch.cleanupBatch(sessionScope);</span>
      }
    }
<span class="fc" id="L167">    return answer;</span>
  }

  /**
   * Long form of the method to execute a query
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the SQL statement to execute
   * @param parameters
   *          - the parameters for the statement
   * @param skipResults
   *          - the number of results to skip
   * @param maxResults
   *          - the maximum number of results to return
   * @param callback
   *          - the row handler for the query
   *
   * @throws SQLException
   *           - if the query fails
   */
  public void executeQuery(StatementScope statementScope, Connection conn, String sql, Object[] parameters,
      int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L193">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L194">    errorContext.setActivity(&quot;executing query&quot;);</span>
<span class="fc" id="L195">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L196">    PreparedStatement ps = null;</span>
<span class="fc" id="L197">    ResultSet rs = null;</span>
<span class="fc" id="L198">    setupResultObjectFactory(statementScope);</span>
    try {
<span class="fc" id="L200">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L201">      Integer rsType = statementScope.getStatement().getResultSetType();</span>
<span class="pc bpc" id="L202" title="1 of 2 branches missed.">      if (rsType != null) {</span>
<span class="nc" id="L203">        ps = prepareStatement(statementScope.getSession(), conn, sql, rsType);</span>
      } else {
<span class="fc" id="L205">        ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
      }
<span class="fc" id="L207">      setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L208">      Integer fetchSize = statementScope.getStatement().getFetchSize();</span>
<span class="pc bpc" id="L209" title="1 of 2 branches missed.">      if (fetchSize != null) {</span>
<span class="nc" id="L210">        ps.setFetchSize(fetchSize.intValue());</span>
      }
<span class="fc" id="L212">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L213">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L214">      errorContext.setMoreInfo(&quot;Check the statement (query failed).&quot;);</span>
<span class="fc" id="L215">      ps.execute();</span>
<span class="fc" id="L216">      errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);</span>

      // Begin ResultSet Handling
<span class="fc" id="L219">      rs = handleMultipleResults(ps, statementScope, skipResults, maxResults, callback);</span>
      // End ResultSet Handling
    } finally {
      try {
<span class="fc" id="L223">        closeResultSet(rs);</span>
      } finally {
<span class="fc" id="L225">        closeStatement(statementScope.getSession(), ps);</span>
<span class="fc" id="L226">        cleanupResultObjectFactory();</span>
      }
    }

<span class="fc" id="L230">  }</span>

  /**
   * Execute a stored procedure that updates data
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the SQL to call the procedure
   * @param parameters
   *          - the parameters for the procedure
   *
   * @return - the rows impacted by the procedure
   *
   * @throws SQLException
   *           - if the procedure fails
   */
  public int executeUpdateProcedure(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="nc" id="L251">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="nc" id="L252">    errorContext.setActivity(&quot;executing update procedure&quot;);</span>
<span class="nc" id="L253">    errorContext.setObjectId(sql);</span>
<span class="nc" id="L254">    CallableStatement cs = null;</span>
<span class="nc" id="L255">    setupResultObjectFactory(statementScope);</span>
<span class="nc" id="L256">    int rows = 0;</span>
    try {
<span class="nc" id="L258">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="nc" id="L259">      cs = prepareCall(statementScope.getSession(), conn, sql);</span>
<span class="nc" id="L260">      setStatementTimeout(statementScope.getStatement(), cs);</span>
<span class="nc" id="L261">      ParameterMap parameterMap = statementScope.getParameterMap();</span>
<span class="nc" id="L262">      ParameterMapping[] mappings = parameterMap.getParameterMappings();</span>
<span class="nc" id="L263">      errorContext.setMoreInfo(&quot;Check the output parameters (register output parameters failed).&quot;);</span>
<span class="nc" id="L264">      registerOutputParameters(cs, mappings);</span>
<span class="nc" id="L265">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="nc" id="L266">      parameterMap.setParameters(statementScope, cs, parameters);</span>
<span class="nc" id="L267">      errorContext.setMoreInfo(&quot;Check the statement (update procedure failed).&quot;);</span>
<span class="nc" id="L268">      cs.execute();</span>
<span class="nc" id="L269">      rows = cs.getUpdateCount();</span>
<span class="nc" id="L270">      errorContext.setMoreInfo(&quot;Check the output parameters (retrieval of output parameters failed).&quot;);</span>
<span class="nc" id="L271">      retrieveOutputParameters(statementScope, cs, mappings, parameters, null);</span>
    } finally {
<span class="nc" id="L273">      closeStatement(statementScope.getSession(), cs);</span>
<span class="nc" id="L274">      cleanupResultObjectFactory();</span>
    }
<span class="nc" id="L276">    return rows;</span>
  }

  /**
   * Execute a stored procedure
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql to call the procedure
   * @param parameters
   *          - the parameters for the procedure
   * @param skipResults
   *          - the number of results to skip
   * @param maxResults
   *          - the maximum number of results to return
   * @param callback
   *          - a row handler for processing the results
   *
   * @throws SQLException
   *           - if the procedure fails
   */
  public void executeQueryProcedure(StatementScope statementScope, Connection conn, String sql, Object[] parameters,
      int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L302">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L303">    errorContext.setActivity(&quot;executing query procedure&quot;);</span>
<span class="fc" id="L304">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L305">    CallableStatement cs = null;</span>
<span class="fc" id="L306">    ResultSet rs = null;</span>
<span class="fc" id="L307">    setupResultObjectFactory(statementScope);</span>
    try {
<span class="fc" id="L309">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L310">      Integer rsType = statementScope.getStatement().getResultSetType();</span>
<span class="pc bpc" id="L311" title="1 of 2 branches missed.">      if (rsType != null) {</span>
<span class="nc" id="L312">        cs = prepareCall(statementScope.getSession(), conn, sql, rsType);</span>
      } else {
<span class="fc" id="L314">        cs = prepareCall(statementScope.getSession(), conn, sql);</span>
      }
<span class="fc" id="L316">      setStatementTimeout(statementScope.getStatement(), cs);</span>
<span class="fc" id="L317">      Integer fetchSize = statementScope.getStatement().getFetchSize();</span>
<span class="pc bpc" id="L318" title="1 of 2 branches missed.">      if (fetchSize != null) {</span>
<span class="nc" id="L319">        cs.setFetchSize(fetchSize.intValue());</span>
      }
<span class="fc" id="L321">      ParameterMap parameterMap = statementScope.getParameterMap();</span>
<span class="fc" id="L322">      ParameterMapping[] mappings = parameterMap.getParameterMappings();</span>
<span class="fc" id="L323">      errorContext.setMoreInfo(&quot;Check the output parameters (register output parameters failed).&quot;);</span>
<span class="fc" id="L324">      registerOutputParameters(cs, mappings);</span>
<span class="fc" id="L325">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L326">      parameterMap.setParameters(statementScope, cs, parameters);</span>
<span class="fc" id="L327">      errorContext.setMoreInfo(&quot;Check the statement (update procedure failed).&quot;);</span>
<span class="fc" id="L328">      cs.execute();</span>
<span class="fc" id="L329">      errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);</span>

      // Begin ResultSet Handling
<span class="fc" id="L332">      rs = handleMultipleResults(cs, statementScope, skipResults, maxResults, callback);</span>
      // End ResultSet Handling
<span class="fc" id="L334">      errorContext.setMoreInfo(&quot;Check the output parameters (retrieval of output parameters failed).&quot;);</span>
<span class="fc" id="L335">      retrieveOutputParameters(statementScope, cs, mappings, parameters, callback);</span>

    } finally {
      try {
<span class="fc" id="L339">        closeResultSet(rs);</span>
      } finally {
<span class="fc" id="L341">        closeStatement(statementScope.getSession(), cs);</span>
<span class="fc" id="L342">        cleanupResultObjectFactory();</span>
      }
    }
<span class="fc" id="L345">  }</span>

  public void init(SqlMapConfiguration config, Properties globalProps) {
    // No implementation is required in DefaultSqlExecutor.
<span class="nc" id="L349">  }</span>

  /**
   * Handle multiple results.
   *
   * @param ps
   *          the ps
   * @param statementScope
   *          the statement scope
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   * @param callback
   *          the callback
   *
   * @return the result set
   *
   * @throws SQLException
   *           the SQL exception
   */
  private ResultSet handleMultipleResults(PreparedStatement ps, StatementScope statementScope, int skipResults,
      int maxResults, RowHandlerCallback callback) throws SQLException {
    ResultSet rs;
<span class="fc" id="L373">    rs = getFirstResultSet(statementScope, ps);</span>
<span class="pc bpc" id="L374" title="1 of 2 branches missed.">    if (rs != null) {</span>
<span class="fc" id="L375">      handleResults(statementScope, rs, skipResults, maxResults, callback);</span>
    }

    // Multiple ResultSet handling
<span class="fc bfc" id="L379" title="All 2 branches covered.">    if (callback.getRowHandler() instanceof DefaultRowHandler) {</span>
<span class="fc" id="L380">      MappedStatement statement = statementScope.getStatement();</span>
<span class="fc" id="L381">      DefaultRowHandler defaultRowHandler = ((DefaultRowHandler) callback.getRowHandler());</span>
<span class="fc bfc" id="L382" title="All 2 branches covered.">      if (statement.hasMultipleResultMaps()) {</span>
<span class="fc" id="L383">        List multipleResults = new ArrayList();</span>
<span class="fc" id="L384">        multipleResults.add(defaultRowHandler.getList());</span>
<span class="fc" id="L385">        ResultMap[] resultMaps = statement.getAdditionalResultMaps();</span>
<span class="fc" id="L386">        int i = 0;</span>
<span class="fc bfc" id="L387" title="All 2 branches covered.">        while (moveToNextResultsSafely(statementScope, ps)) {</span>
<span class="pc bpc" id="L388" title="1 of 2 branches missed.">          if (i &gt;= resultMaps.length)</span>
<span class="nc" id="L389">            break;</span>
<span class="fc" id="L390">          ResultMap rm = resultMaps[i];</span>
<span class="fc" id="L391">          statementScope.setResultMap(rm);</span>
<span class="fc" id="L392">          rs = ps.getResultSet();</span>
<span class="fc" id="L393">          DefaultRowHandler rh = new DefaultRowHandler();</span>
<span class="fc" id="L394">          handleResults(statementScope, rs, skipResults, maxResults, new RowHandlerCallback(rm, null, rh));</span>
<span class="fc" id="L395">          multipleResults.add(rh.getList());</span>
<span class="fc" id="L396">          i++;</span>
<span class="fc" id="L397">        }</span>
<span class="fc" id="L398">        defaultRowHandler.setList(multipleResults);</span>
<span class="fc" id="L399">        statementScope.setResultMap(statement.getResultMap());</span>
<span class="fc" id="L400">      } else {</span>
<span class="pc bpc" id="L401" title="1 of 2 branches missed.">        while (moveToNextResultsSafely(statementScope, ps))</span>
<span class="nc" id="L402">          ;</span>
      }
    }
    // End additional ResultSet handling
<span class="fc" id="L406">    return rs;</span>
  }

  /**
   * Gets the first result set.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return the first result set
   *
   * @throws SQLException
   *           the SQL exception
   */
  private ResultSet getFirstResultSet(StatementScope scope, Statement stmt) throws SQLException {
<span class="fc" id="L423">    ResultSet rs = null;</span>
<span class="fc" id="L424">    boolean hasMoreResults = true;</span>
<span class="pc bpc" id="L425" title="1 of 2 branches missed.">    while (hasMoreResults) {</span>
<span class="fc" id="L426">      rs = stmt.getResultSet();</span>
<span class="pc bpc" id="L427" title="1 of 2 branches missed.">      if (rs != null) {</span>
<span class="fc" id="L428">        break;</span>
      }
<span class="nc" id="L430">      hasMoreResults = moveToNextResultsIfPresent(scope, stmt);</span>
    }
<span class="fc" id="L432">    return rs;</span>
  }

  /**
   * Move to next results if present.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if successful
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean moveToNextResultsIfPresent(StatementScope scope, Statement stmt) throws SQLException {
    boolean moreResults;
    // This is the messed up JDBC approach for determining if there are more results
<span class="nc" id="L451">    boolean movedToNextResultsSafely = moveToNextResultsSafely(scope, stmt);</span>
<span class="nc" id="L452">    int updateCount = stmt.getUpdateCount();</span>

<span class="nc bnc" id="L454" title="All 4 branches missed.">    moreResults = !(!movedToNextResultsSafely &amp;&amp; (updateCount == -1));</span>

    // ibatis-384: workaround for mysql not returning -1 for stmt.getUpdateCount()
<span class="nc bnc" id="L457" title="All 2 branches missed.">    if (moreResults == true) {</span>
<span class="nc bnc" id="L458" title="All 4 branches missed.">      moreResults = !(!movedToNextResultsSafely &amp;&amp; !isMultipleResultSetSupportPresent(scope, stmt));</span>
    }

<span class="nc" id="L461">    return moreResults;</span>
  }

  /**
   * Move to next results safely.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if successful
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean moveToNextResultsSafely(StatementScope scope, Statement stmt) throws SQLException {
<span class="pc bpc" id="L478" title="1 of 2 branches missed.">    if (isMultipleResultSetSupportPresent(scope, stmt)) {</span>
<span class="fc" id="L479">      return stmt.getMoreResults();</span>
    }
<span class="nc" id="L481">    return false;</span>
  }

  /**
   * checks whether multiple result set support is present - either by direct support of the database driver or by
   * forcing it.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if is multiple result set support present
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean isMultipleResultSetSupportPresent(StatementScope scope, Statement stmt) throws SQLException {
<span class="pc bpc" id="L499" title="2 of 4 branches missed.">    return forceMultipleResultSetSupport(scope) || stmt.getConnection().getMetaData().supportsMultipleResultSets();</span>
  }

  /**
   * Force multiple result set support.
   *
   * @param scope
   *          the scope
   *
   * @return true, if successful
   */
  private boolean forceMultipleResultSetSupport(StatementScope scope) {
<span class="fc" id="L511">    return ((SqlMapClientImpl) scope.getSession().getSqlMapClient()).getDelegate().isForceMultipleResultSetSupport();</span>
  }

  /**
   * Handle results.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void handleResults(StatementScope statementScope, ResultSet rs, int skipResults, int maxResults,
      RowHandlerCallback callback) throws SQLException {
    try {
<span class="fc" id="L534">      statementScope.setResultSet(rs);</span>
<span class="fc" id="L535">      ResultMap resultMap = statementScope.getResultMap();</span>
<span class="pc bpc" id="L536" title="1 of 2 branches missed.">      if (resultMap != null) {</span>
        // Skip Results
<span class="pc bpc" id="L538" title="1 of 2 branches missed.">        if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {</span>
<span class="nc bnc" id="L539" title="All 2 branches missed.">          if (skipResults &gt; 0) {</span>
<span class="nc" id="L540">            rs.absolute(skipResults);</span>
          }
        } else {
<span class="fc bfc" id="L543" title="All 2 branches covered.">          for (int i = 0; i &lt; skipResults; i++) {</span>
<span class="fc bfc" id="L544" title="All 2 branches covered.">            if (!rs.next()) {</span>
<span class="fc" id="L545">              return;</span>
            }
          }
        }

        // Get Results
<span class="fc" id="L551">        int resultsFetched = 0;</span>
<span class="fc bfc" id="L552" title="All 6 branches covered.">        while ((maxResults == NO_MAXIMUM_RESULTS || resultsFetched &lt; maxResults) &amp;&amp; rs.next()) {</span>
<span class="fc" id="L553">          Object[] columnValues = resultMap.resolveSubMap(statementScope, rs).getResults(statementScope, rs);</span>
<span class="fc" id="L554">          callback.handleResultObject(statementScope, columnValues, rs);</span>
<span class="fc" id="L555">          resultsFetched++;</span>
<span class="fc" id="L556">        }</span>
      }
    } finally {
<span class="fc" id="L559">      statementScope.setResultSet(null);</span>
    }
<span class="fc" id="L561">  }</span>

  /**
   * Retrieve output parameters.
   *
   * @param statementScope
   *          the statement scope
   * @param cs
   *          the cs
   * @param mappings
   *          the mappings
   * @param parameters
   *          the parameters
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void retrieveOutputParameters(StatementScope statementScope, CallableStatement cs,
      ParameterMapping[] mappings, Object[] parameters, RowHandlerCallback callback) throws SQLException {
<span class="fc bfc" id="L582" title="All 2 branches covered.">    for (int i = 0; i &lt; mappings.length; i++) {</span>
<span class="fc" id="L583">      ParameterMapping mapping = ((ParameterMapping) mappings[i]);</span>
<span class="pc bpc" id="L584" title="1 of 2 branches missed.">      if (mapping.isOutputAllowed()) {</span>
<span class="nc bnc" id="L585" title="All 2 branches missed.">        if (&quot;java.sql.ResultSet&quot;.equalsIgnoreCase(mapping.getJavaTypeName())) {</span>
<span class="nc" id="L586">          ResultSet rs = (ResultSet) cs.getObject(i + 1);</span>
          ResultMap resultMap;
<span class="nc bnc" id="L588" title="All 2 branches missed.">          if (mapping.getResultMapName() == null) {</span>
<span class="nc" id="L589">            resultMap = statementScope.getResultMap();</span>
<span class="nc" id="L590">            handleOutputParameterResults(statementScope, resultMap, rs, callback);</span>
          } else {
<span class="nc" id="L592">            SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="nc" id="L593">            resultMap = client.getDelegate().getResultMap(mapping.getResultMapName());</span>
<span class="nc" id="L594">            DefaultRowHandler rowHandler = new DefaultRowHandler();</span>
<span class="nc" id="L595">            RowHandlerCallback handlerCallback = new RowHandlerCallback(resultMap, null, rowHandler);</span>
<span class="nc" id="L596">            handleOutputParameterResults(statementScope, resultMap, rs, handlerCallback);</span>
<span class="nc" id="L597">            parameters[i] = rowHandler.getList();</span>
          }
<span class="nc" id="L599">          rs.close();</span>
<span class="nc" id="L600">        } else {</span>
<span class="nc" id="L601">          parameters[i] = mapping.getTypeHandler().getResult(cs, i + 1);</span>
        }
      }
    }
<span class="fc" id="L605">  }</span>

  /**
   * Register output parameters.
   *
   * @param cs
   *          the cs
   * @param mappings
   *          the mappings
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void registerOutputParameters(CallableStatement cs, ParameterMapping[] mappings) throws SQLException {
<span class="fc bfc" id="L619" title="All 2 branches covered.">    for (int i = 0; i &lt; mappings.length; i++) {</span>
<span class="fc" id="L620">      ParameterMapping mapping = ((ParameterMapping) mappings[i]);</span>
<span class="pc bpc" id="L621" title="1 of 2 branches missed.">      if (mapping.isOutputAllowed()) {</span>
<span class="nc bnc" id="L622" title="All 4 branches missed.">        if (null != mapping.getTypeName() &amp;&amp; !mapping.getTypeName().equals(&quot;&quot;)) { // @added</span>
<span class="nc" id="L623">          cs.registerOutParameter(i + 1, mapping.getJdbcType(), mapping.getTypeName());</span>
        } else {
<span class="nc bnc" id="L625" title="All 2 branches missed.">          if (mapping.getNumericScale() != null</span>
<span class="nc bnc" id="L626" title="All 4 branches missed.">              &amp;&amp; (mapping.getJdbcType() == Types.NUMERIC || mapping.getJdbcType() == Types.DECIMAL)) {</span>
<span class="nc" id="L627">            cs.registerOutParameter(i + 1, mapping.getJdbcType(), mapping.getNumericScale().intValue());</span>
          } else {
<span class="nc" id="L629">            cs.registerOutParameter(i + 1, mapping.getJdbcType());</span>
          }
        }
      }
    }
<span class="fc" id="L634">  }</span>

  /**
   * Handle output parameter results.
   *
   * @param statementScope
   *          the statement scope
   * @param resultMap
   *          the result map
   * @param rs
   *          the rs
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void handleOutputParameterResults(StatementScope statementScope, ResultMap resultMap, ResultSet rs,
      RowHandlerCallback callback) throws SQLException {
<span class="nc" id="L653">    ResultMap orig = statementScope.getResultMap();</span>
    try {
<span class="nc" id="L655">      statementScope.setResultSet(rs);</span>
<span class="nc bnc" id="L656" title="All 2 branches missed.">      if (resultMap != null) {</span>
<span class="nc" id="L657">        statementScope.setResultMap(resultMap);</span>

        // Get Results
<span class="nc bnc" id="L660" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L661">          Object[] columnValues = resultMap.resolveSubMap(statementScope, rs).getResults(statementScope, rs);</span>
<span class="nc" id="L662">          callback.handleResultObject(statementScope, columnValues, rs);</span>
<span class="nc" id="L663">        }</span>
      }
    } finally {
<span class="nc" id="L666">      statementScope.setResultSet(null);</span>
<span class="nc" id="L667">      statementScope.setResultMap(orig);</span>
    }
<span class="nc" id="L669">  }</span>

  /**
   * Clean up any batches on the session
   *
   * @param sessionScope
   *          - the session to clean up
   */
  public void cleanup(SessionScope sessionScope) {
<span class="fc" id="L678">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="fc bfc" id="L679" title="All 2 branches covered.">    if (batch != null) {</span>
<span class="fc" id="L680">      batch.cleanupBatch(sessionScope);</span>
<span class="fc" id="L681">      sessionScope.setBatch(null);</span>
    }
<span class="fc" id="L683">  }</span>

  /**
   * Prepare statement.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   * @param rsType
   *          the rs type
   *
   * @return the prepared statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private PreparedStatement prepareStatement(SessionScope sessionScope, Connection conn, String sql, Integer rsType)
      throws SQLException {
<span class="nc" id="L704">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="nc bnc" id="L705" title="All 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L706">      return sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="nc" id="L708">      PreparedStatement ps = conn.prepareStatement(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);</span>
<span class="nc" id="L709">      sessionScope.putPreparedStatement(delegate, sql, ps);</span>
<span class="nc" id="L710">      return ps;</span>
    }
  }

  /**
   * Prepare call.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   * @param rsType
   *          the rs type
   *
   * @return the callable statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private CallableStatement prepareCall(SessionScope sessionScope, Connection conn, String sql, Integer rsType)
      throws SQLException {
<span class="nc" id="L733">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="nc bnc" id="L734" title="All 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L735">      return (CallableStatement) sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="nc" id="L737">      CallableStatement cs = conn.prepareCall(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);</span>
<span class="nc" id="L738">      sessionScope.putPreparedStatement(delegate, sql, cs);</span>
<span class="nc" id="L739">      return cs;</span>
    }
  }

  /**
   * Prepare statement.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   *
   * @return the prepared statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private static PreparedStatement prepareStatement(SessionScope sessionScope, Connection conn, String sql)
      throws SQLException {
<span class="fc" id="L760">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="fc bfc" id="L761" title="All 2 branches covered.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="fc" id="L762">      return sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="fc" id="L764">      PreparedStatement ps = conn.prepareStatement(sql);</span>
<span class="fc" id="L765">      sessionScope.putPreparedStatement(delegate, sql, ps);</span>
<span class="fc" id="L766">      return ps;</span>
    }
  }

  /**
   * Prepare call.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   *
   * @return the callable statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private CallableStatement prepareCall(SessionScope sessionScope, Connection conn, String sql) throws SQLException {
<span class="fc" id="L786">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="pc bpc" id="L787" title="1 of 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L788">      return (CallableStatement) sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="fc" id="L790">      CallableStatement cs = conn.prepareCall(sql);</span>
<span class="fc" id="L791">      sessionScope.putPreparedStatement(delegate, sql, cs);</span>
<span class="fc" id="L792">      return cs;</span>
    }
  }

  /**
   * Close statement.
   *
   * @param sessionScope
   *          the session scope
   * @param ps
   *          the ps
   */
  private static void closeStatement(SessionScope sessionScope, PreparedStatement ps) {
<span class="fc bfc" id="L805" title="All 2 branches covered.">    if (ps != null) {</span>
<span class="fc bfc" id="L806" title="All 2 branches covered.">      if (!sessionScope.hasPreparedStatement(ps)) {</span>
        try {
<span class="fc" id="L808">          ps.close();</span>
<span class="nc" id="L809">        } catch (SQLException e) {</span>
          // ignore
<span class="fc" id="L811">        }</span>
      }
    }
<span class="fc" id="L814">  }</span>

  /**
   * Close result set.
   *
   * @param rs
   *          the rs
   */
  private static void closeResultSet(ResultSet rs) {
<span class="fc bfc" id="L823" title="All 2 branches covered.">    if (rs != null) {</span>
      try {
<span class="fc" id="L825">        rs.close();</span>
<span class="nc" id="L826">      } catch (SQLException e) {</span>
        // ignore
<span class="fc" id="L828">      }</span>
    }
<span class="fc" id="L830">  }</span>

  /**
   * Sets the statement timeout.
   *
   * @param mappedStatement
   *          the mapped statement
   * @param statement
   *          the statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private static void setStatementTimeout(MappedStatement mappedStatement, Statement statement) throws SQLException {
<span class="pc bpc" id="L844" title="1 of 2 branches missed.">    if (mappedStatement.getTimeout() != null) {</span>
<span class="nc" id="L845">      statement.setQueryTimeout(mappedStatement.getTimeout().intValue());</span>
    }
<span class="fc" id="L847">  }</span>

  //
  // Inner Classes
  //

  /**
   * The Class Batch.
   */
  private static class Batch {

    /** The current sql. */
    private String currentSql;

    /** The statement list. */
<span class="fc" id="L862">    private List statementList = new ArrayList();</span>

    /** The batch result list. */
<span class="fc" id="L865">    private List batchResultList = new ArrayList();</span>

    /** The size. */
    private int size;

    /**
     * Create a new batch.
     */
<span class="fc" id="L873">    public Batch() {</span>
<span class="fc" id="L874">      this.size = 0;</span>
<span class="fc" id="L875">    }</span>

    /**
     * Getter for the batch size.
     *
     * @return - the batch size
     */
    public int getSize() {
<span class="nc" id="L883">      return size;</span>
    }

    /**
     * Add a prepared statement to the batch.
     *
     * @param statementScope
     *          - the request scope
     * @param conn
     *          - the database connection
     * @param sql
     *          - the SQL to add
     * @param parameters
     *          - the parameters for the SQL
     *
     * @throws SQLException
     *           - if the prepare for the SQL fails
     */
    public void addBatch(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
        throws SQLException {
<span class="fc" id="L903">      PreparedStatement ps = null;</span>
<span class="fc bfc" id="L904" title="All 4 branches covered.">      if (currentSql != null &amp;&amp; currentSql.equals(sql)) {</span>
<span class="fc" id="L905">        int last = statementList.size() - 1;</span>
<span class="fc" id="L906">        ps = (PreparedStatement) statementList.get(last);</span>
<span class="fc" id="L907">      } else {</span>
<span class="fc" id="L908">        ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
<span class="fc" id="L909">        setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L910">        currentSql = sql;</span>
<span class="fc" id="L911">        statementList.add(ps);</span>
<span class="fc" id="L912">        batchResultList.add(new BatchResult(statementScope.getStatement().getId(), sql));</span>
      }
<span class="fc" id="L914">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L915">      ps.addBatch();</span>
<span class="fc" id="L916">      size++;</span>
<span class="fc" id="L917">    }</span>

    /**
     * TODO (Jeff Butler) - maybe this method should be deprecated in some release, and then removed in some even later
     * release. executeBatchDetailed gives much more complete information.
     * &lt;p&gt;
     * Execute the current session's batch
     *
     * @return - the number of rows updated
     *
     * @throws SQLException
     *           - if the batch fails
     */
    public int executeBatch() throws SQLException {
<span class="fc" id="L931">      int totalRowCount = 0;</span>
<span class="fc bfc" id="L932" title="All 2 branches covered.">      for (int i = 0, n = statementList.size(); i &lt; n; i++) {</span>
<span class="fc" id="L933">        PreparedStatement ps = (PreparedStatement) statementList.get(i);</span>
<span class="fc" id="L934">        int[] rowCounts = ps.executeBatch();</span>
<span class="fc bfc" id="L935" title="All 2 branches covered.">        for (int j = 0; j &lt; rowCounts.length; j++) {</span>
<span class="pc bpc" id="L936" title="1 of 2 branches missed.">          if (rowCounts[j] == Statement.SUCCESS_NO_INFO) {</span>
            // do nothing
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">          } else if (rowCounts[j] == Statement.EXECUTE_FAILED) {</span>
<span class="nc" id="L939">            throw new SQLException(&quot;The batched statement at index &quot; + j + &quot; failed to execute.&quot;);</span>
          } else {
<span class="fc" id="L941">            totalRowCount += rowCounts[j];</span>
          }
        }
      }
<span class="fc" id="L945">      return totalRowCount;</span>
    }

    /**
     * Batch execution method that returns all the information the driver has to offer.
     *
     * @return a List of BatchResult objects
     *
     * @throws SQLException
     *           if a database access error occurs, or the drive does not support batch statements
     * @throws BatchException
     *           if the driver throws BatchUpdateException
     */
    public List executeBatchDetailed() throws SQLException, BatchException {
<span class="fc" id="L959">      List answer = new ArrayList();</span>
<span class="fc bfc" id="L960" title="All 2 branches covered.">      for (int i = 0, n = statementList.size(); i &lt; n; i++) {</span>
<span class="fc" id="L961">        BatchResult br = (BatchResult) batchResultList.get(i);</span>
<span class="fc" id="L962">        PreparedStatement ps = (PreparedStatement) statementList.get(i);</span>
        try {
<span class="fc" id="L964">          br.setUpdateCounts(ps.executeBatch());</span>
<span class="fc" id="L965">        } catch (BatchUpdateException e) {</span>
<span class="fc" id="L966">          StringBuilder message = new StringBuilder();</span>
<span class="fc" id="L967">          message.append(&quot;Sub batch number &quot;);</span>
<span class="fc" id="L968">          message.append(i + 1);</span>
<span class="fc" id="L969">          message.append(&quot; failed.&quot;);</span>
<span class="pc bpc" id="L970" title="1 of 2 branches missed.">          if (i &gt; 0) {</span>
<span class="fc" id="L971">            message.append(&quot; &quot;);</span>
<span class="fc" id="L972">            message.append(i);</span>
<span class="fc" id="L973">            message.append(&quot; prior sub batch(s) completed successfully, but will be rolled back.&quot;);</span>
          }
<span class="fc" id="L975">          throw new BatchException(message.toString(), e, answer, br.getStatementId(), br.getSql());</span>
<span class="fc" id="L976">        }</span>
<span class="fc" id="L977">        answer.add(br);</span>
      }
<span class="fc" id="L979">      return answer;</span>
    }

    /**
     * Close all the statements in the batch and clear all the statements.
     *
     * @param sessionScope
     *          the session scope
     */
    public void cleanupBatch(SessionScope sessionScope) {
<span class="fc bfc" id="L989" title="All 2 branches covered.">      for (int i = 0, n = statementList.size(); i &lt; n; i++) {</span>
<span class="fc" id="L990">        PreparedStatement ps = (PreparedStatement) statementList.get(i);</span>
<span class="fc" id="L991">        closeStatement(sessionScope, ps);</span>
      }
<span class="fc" id="L993">      currentSql = null;</span>
<span class="fc" id="L994">      statementList.clear();</span>
<span class="fc" id="L995">      batchResultList.clear();</span>
<span class="fc" id="L996">      size = 0;</span>
<span class="fc" id="L997">    }</span>
  }

  /**
   * Sets the up result object factory.
   *
   * @param statementScope
   *          the new up result object factory
   */
  private void setupResultObjectFactory(StatementScope statementScope) {
<span class="fc" id="L1007">    SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="fc" id="L1008">    ResultObjectFactoryUtil.setupResultObjectFactory(client.getResultObjectFactory(),</span>
<span class="fc" id="L1009">        statementScope.getStatement().getId());</span>
<span class="fc" id="L1010">  }</span>

  /**
   * Cleanup result object factory.
   */
  private void cleanupResultObjectFactory() {
<span class="fc" id="L1016">    ResultObjectFactoryUtil.cleanupResultObjectFactory();</span>
<span class="fc" id="L1017">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>