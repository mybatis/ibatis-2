<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang=""><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultSqlExecutor.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.execution</a> &gt; <span class="el_source">DefaultSqlExecutor.java</span></div><h1>DefaultSqlExecutor.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004-2025 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.execution;

import com.ibatis.sqlmap.engine.config.SqlMapConfiguration;
import com.ibatis.sqlmap.engine.impl.SqlMapClientImpl;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMap;
import com.ibatis.sqlmap.engine.mapping.parameter.ParameterMapping;
import com.ibatis.sqlmap.engine.mapping.result.ResultMap;
import com.ibatis.sqlmap.engine.mapping.result.ResultObjectFactoryUtil;
import com.ibatis.sqlmap.engine.mapping.statement.DefaultRowHandler;
import com.ibatis.sqlmap.engine.mapping.statement.MappedStatement;
import com.ibatis.sqlmap.engine.mapping.statement.RowHandlerCallback;
import com.ibatis.sqlmap.engine.scope.ErrorContext;
import com.ibatis.sqlmap.engine.scope.SessionScope;
import com.ibatis.sqlmap.engine.scope.StatementScope;

import java.sql.BatchUpdateException;
import java.sql.CallableStatement;
import java.sql.Connection;
import java.sql.PreparedStatement;
import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.sql.Types;
import java.util.ArrayList;
import java.util.List;
import java.util.Properties;

/**
 * Class responsible for executing the SQL.
 */
<span class="fc" id="L47">public class DefaultSqlExecutor implements SqlExecutor {</span>

  /**
   * Execute an update
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql statement to execute
   * @param parameters
   *          - the parameters for the sql statement
   *
   * @return - the number of records changed
   *
   * @throws SQLException
   *           - if the update fails
   */
  @Override
  public int executeUpdate(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="fc" id="L69">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L70">    errorContext.setActivity(&quot;executing update&quot;);</span>
<span class="fc" id="L71">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L72">    PreparedStatement ps = null;</span>
<span class="fc" id="L73">    setupResultObjectFactory(statementScope);</span>
<span class="fc" id="L74">    int rows = 0;</span>
    try {
<span class="fc" id="L76">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L77">      ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
<span class="fc" id="L78">      setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L79">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L80">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L81">      errorContext.setMoreInfo(&quot;Check the statement (update failed).&quot;);</span>
<span class="fc" id="L82">      ps.execute();</span>
<span class="fc" id="L83">      rows = ps.getUpdateCount();</span>
    } finally {
<span class="fc" id="L85">      closeStatement(statementScope.getSession(), ps);</span>
<span class="fc" id="L86">      cleanupResultObjectFactory();</span>
    }
<span class="fc" id="L88">    return rows;</span>
  }

  /**
   * Adds a statement to a batch
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql statement
   * @param parameters
   *          - the parameters for the statement
   *
   * @throws SQLException
   *           - if the statement fails
   */
  @Override
  public void addBatch(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="fc" id="L109">    Batch batch = (Batch) statementScope.getSession().getBatch();</span>
<span class="fc bfc" id="L110" title="All 2 branches covered.">    if (batch == null) {</span>
<span class="fc" id="L111">      batch = new Batch();</span>
<span class="fc" id="L112">      statementScope.getSession().setBatch(batch);</span>
    }
<span class="fc" id="L114">    batch.addBatch(statementScope, conn, sql, parameters);</span>
<span class="fc" id="L115">  }</span>

  /**
   * Execute a batch of statements
   *
   * @param sessionScope
   *          - the session scope
   *
   * @return - the number of rows impacted by the batch
   *
   * @throws SQLException
   *           - if a statement fails
   */
  @Override
  public int executeBatch(SessionScope sessionScope) throws SQLException {
<span class="fc" id="L130">    int rows = 0;</span>
<span class="fc" id="L131">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="fc bfc" id="L132" title="All 2 branches covered.">    if (batch != null) {</span>
      try {
<span class="fc" id="L134">        rows = batch.executeBatch();</span>
      } finally {
<span class="fc" id="L136">        batch.cleanupBatch(sessionScope);</span>
      }
    }
<span class="fc" id="L139">    return rows;</span>
  }

  /**
   * Execute a batch of statements
   *
   * @param sessionScope
   *          - the session scope
   *
   * @return - a List of BatchResult objects (may be null if no batch has been initiated). There will be one BatchResult
   *         object in the list for each sub-batch executed
   *
   * @throws SQLException
   *           if a database access error occurs, or the drive does not support batch statements
   * @throws BatchException
   *           if the driver throws BatchUpdateException
   */
  @Override
  public List executeBatchDetailed(SessionScope sessionScope) throws SQLException, BatchException {
<span class="fc" id="L158">    List answer = null;</span>
<span class="fc" id="L159">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="pc bpc" id="L160" title="1 of 2 branches missed.">    if (batch != null) {</span>
      try {
<span class="fc" id="L162">        answer = batch.executeBatchDetailed();</span>
      } finally {
<span class="fc" id="L164">        batch.cleanupBatch(sessionScope);</span>
      }
    }
<span class="fc" id="L167">    return answer;</span>
  }

  /**
   * Long form of the method to execute a query
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the SQL statement to execute
   * @param parameters
   *          - the parameters for the statement
   * @param skipResults
   *          - the number of results to skip
   * @param maxResults
   *          - the maximum number of results to return
   * @param callback
   *          - the row handler for the query
   *
   * @throws SQLException
   *           - if the query fails
   */
  @Override
  public void executeQuery(StatementScope statementScope, Connection conn, String sql, Object[] parameters,
      int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L194">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L195">    errorContext.setActivity(&quot;executing query&quot;);</span>
<span class="fc" id="L196">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L197">    PreparedStatement ps = null;</span>
<span class="fc" id="L198">    ResultSet rs = null;</span>
<span class="fc" id="L199">    setupResultObjectFactory(statementScope);</span>
    try {
<span class="fc" id="L201">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L202">      Integer rsType = statementScope.getStatement().getResultSetType();</span>
<span class="pc bpc" id="L203" title="1 of 2 branches missed.">      if (rsType != null) {</span>
<span class="nc" id="L204">        ps = prepareStatement(statementScope.getSession(), conn, sql, rsType);</span>
      } else {
<span class="fc" id="L206">        ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
      }
<span class="fc" id="L208">      setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L209">      Integer fetchSize = statementScope.getStatement().getFetchSize();</span>
<span class="pc bpc" id="L210" title="1 of 2 branches missed.">      if (fetchSize != null) {</span>
<span class="nc" id="L211">        ps.setFetchSize(fetchSize.intValue());</span>
      }
<span class="fc" id="L213">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L214">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L215">      errorContext.setMoreInfo(&quot;Check the statement (query failed).&quot;);</span>
<span class="fc" id="L216">      ps.execute();</span>
<span class="fc" id="L217">      errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);</span>

      // Begin ResultSet Handling
<span class="fc" id="L220">      rs = handleMultipleResults(ps, statementScope, skipResults, maxResults, callback);</span>
      // End ResultSet Handling
    } finally {
      try {
<span class="fc" id="L224">        closeResultSet(rs);</span>
      } finally {
<span class="fc" id="L226">        closeStatement(statementScope.getSession(), ps);</span>
<span class="fc" id="L227">        cleanupResultObjectFactory();</span>
      }
    }

<span class="fc" id="L231">  }</span>

  /**
   * Execute a stored procedure that updates data
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the SQL to call the procedure
   * @param parameters
   *          - the parameters for the procedure
   *
   * @return - the rows impacted by the procedure
   *
   * @throws SQLException
   *           - if the procedure fails
   */
  @Override
  public int executeUpdateProcedure(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
      throws SQLException {
<span class="nc" id="L253">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="nc" id="L254">    errorContext.setActivity(&quot;executing update procedure&quot;);</span>
<span class="nc" id="L255">    errorContext.setObjectId(sql);</span>
<span class="nc" id="L256">    CallableStatement cs = null;</span>
<span class="nc" id="L257">    setupResultObjectFactory(statementScope);</span>
<span class="nc" id="L258">    int rows = 0;</span>
    try {
<span class="nc" id="L260">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="nc" id="L261">      cs = prepareCall(statementScope.getSession(), conn, sql);</span>
<span class="nc" id="L262">      setStatementTimeout(statementScope.getStatement(), cs);</span>
<span class="nc" id="L263">      ParameterMap parameterMap = statementScope.getParameterMap();</span>
<span class="nc" id="L264">      ParameterMapping[] mappings = parameterMap.getParameterMappings();</span>
<span class="nc" id="L265">      errorContext.setMoreInfo(&quot;Check the output parameters (register output parameters failed).&quot;);</span>
<span class="nc" id="L266">      registerOutputParameters(cs, mappings);</span>
<span class="nc" id="L267">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="nc" id="L268">      parameterMap.setParameters(statementScope, cs, parameters);</span>
<span class="nc" id="L269">      errorContext.setMoreInfo(&quot;Check the statement (update procedure failed).&quot;);</span>
<span class="nc" id="L270">      cs.execute();</span>
<span class="nc" id="L271">      rows = cs.getUpdateCount();</span>
<span class="nc" id="L272">      errorContext.setMoreInfo(&quot;Check the output parameters (retrieval of output parameters failed).&quot;);</span>
<span class="nc" id="L273">      retrieveOutputParameters(statementScope, cs, mappings, parameters, null);</span>
    } finally {
<span class="nc" id="L275">      closeStatement(statementScope.getSession(), cs);</span>
<span class="nc" id="L276">      cleanupResultObjectFactory();</span>
    }
<span class="nc" id="L278">    return rows;</span>
  }

  /**
   * Execute a stored procedure
   *
   * @param statementScope
   *          - the request scope
   * @param conn
   *          - the database connection
   * @param sql
   *          - the sql to call the procedure
   * @param parameters
   *          - the parameters for the procedure
   * @param skipResults
   *          - the number of results to skip
   * @param maxResults
   *          - the maximum number of results to return
   * @param callback
   *          - a row handler for processing the results
   *
   * @throws SQLException
   *           - if the procedure fails
   */
  @Override
  public void executeQueryProcedure(StatementScope statementScope, Connection conn, String sql, Object[] parameters,
      int skipResults, int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L305">    ErrorContext errorContext = statementScope.getErrorContext();</span>
<span class="fc" id="L306">    errorContext.setActivity(&quot;executing query procedure&quot;);</span>
<span class="fc" id="L307">    errorContext.setObjectId(sql);</span>
<span class="fc" id="L308">    CallableStatement cs = null;</span>
<span class="fc" id="L309">    ResultSet rs = null;</span>
<span class="fc" id="L310">    setupResultObjectFactory(statementScope);</span>
    try {
<span class="fc" id="L312">      errorContext.setMoreInfo(&quot;Check the SQL Statement (preparation failed).&quot;);</span>
<span class="fc" id="L313">      Integer rsType = statementScope.getStatement().getResultSetType();</span>
<span class="pc bpc" id="L314" title="1 of 2 branches missed.">      if (rsType != null) {</span>
<span class="nc" id="L315">        cs = prepareCall(statementScope.getSession(), conn, sql, rsType);</span>
      } else {
<span class="fc" id="L317">        cs = prepareCall(statementScope.getSession(), conn, sql);</span>
      }
<span class="fc" id="L319">      setStatementTimeout(statementScope.getStatement(), cs);</span>
<span class="fc" id="L320">      Integer fetchSize = statementScope.getStatement().getFetchSize();</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">      if (fetchSize != null) {</span>
<span class="nc" id="L322">        cs.setFetchSize(fetchSize.intValue());</span>
      }
<span class="fc" id="L324">      ParameterMap parameterMap = statementScope.getParameterMap();</span>
<span class="fc" id="L325">      ParameterMapping[] mappings = parameterMap.getParameterMappings();</span>
<span class="fc" id="L326">      errorContext.setMoreInfo(&quot;Check the output parameters (register output parameters failed).&quot;);</span>
<span class="fc" id="L327">      registerOutputParameters(cs, mappings);</span>
<span class="fc" id="L328">      errorContext.setMoreInfo(&quot;Check the parameters (set parameters failed).&quot;);</span>
<span class="fc" id="L329">      parameterMap.setParameters(statementScope, cs, parameters);</span>
<span class="fc" id="L330">      errorContext.setMoreInfo(&quot;Check the statement (update procedure failed).&quot;);</span>
<span class="fc" id="L331">      cs.execute();</span>
<span class="fc" id="L332">      errorContext.setMoreInfo(&quot;Check the results (failed to retrieve results).&quot;);</span>

      // Begin ResultSet Handling
<span class="fc" id="L335">      rs = handleMultipleResults(cs, statementScope, skipResults, maxResults, callback);</span>
      // End ResultSet Handling
<span class="fc" id="L337">      errorContext.setMoreInfo(&quot;Check the output parameters (retrieval of output parameters failed).&quot;);</span>
<span class="fc" id="L338">      retrieveOutputParameters(statementScope, cs, mappings, parameters, callback);</span>

    } finally {
      try {
<span class="fc" id="L342">        closeResultSet(rs);</span>
      } finally {
<span class="fc" id="L344">        closeStatement(statementScope.getSession(), cs);</span>
<span class="fc" id="L345">        cleanupResultObjectFactory();</span>
      }
    }
<span class="fc" id="L348">  }</span>

  @Override
  public void init(SqlMapConfiguration config, Properties globalProps) {
    // No implementation is required in DefaultSqlExecutor.
<span class="nc" id="L353">  }</span>

  /**
   * Handle multiple results.
   *
   * @param ps
   *          the ps
   * @param statementScope
   *          the statement scope
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   * @param callback
   *          the callback
   *
   * @return the result set
   *
   * @throws SQLException
   *           the SQL exception
   */
  private ResultSet handleMultipleResults(PreparedStatement ps, StatementScope statementScope, int skipResults,
      int maxResults, RowHandlerCallback callback) throws SQLException {
<span class="fc" id="L376">    ResultSet rs = getFirstResultSet(statementScope, ps);</span>
<span class="pc bpc" id="L377" title="1 of 2 branches missed.">    if (rs != null) {</span>
<span class="fc" id="L378">      handleResults(statementScope, rs, skipResults, maxResults, callback);</span>
    }

    // Multiple ResultSet handling
<span class="fc bfc" id="L382" title="All 2 branches covered.">    if (callback.getRowHandler() instanceof DefaultRowHandler) {</span>
<span class="fc" id="L383">      MappedStatement statement = statementScope.getStatement();</span>
<span class="fc" id="L384">      DefaultRowHandler defaultRowHandler = ((DefaultRowHandler) callback.getRowHandler());</span>
<span class="fc bfc" id="L385" title="All 2 branches covered.">      if (statement.hasMultipleResultMaps()) {</span>
<span class="fc" id="L386">        List multipleResults = new ArrayList&lt;&gt;();</span>
<span class="fc" id="L387">        multipleResults.add(defaultRowHandler.getList());</span>
<span class="fc" id="L388">        ResultMap[] resultMaps = statement.getAdditionalResultMaps();</span>
<span class="fc" id="L389">        int i = 0;</span>
<span class="fc bfc" id="L390" title="All 2 branches covered.">        while (moveToNextResultsSafely(statementScope, ps)) {</span>
<span class="pc bpc" id="L391" title="1 of 2 branches missed.">          if (i &gt;= resultMaps.length) {</span>
<span class="nc" id="L392">            break;</span>
          }
<span class="fc" id="L394">          ResultMap rm = resultMaps[i];</span>
<span class="fc" id="L395">          statementScope.setResultMap(rm);</span>
<span class="fc" id="L396">          rs = ps.getResultSet();</span>
<span class="fc" id="L397">          DefaultRowHandler rh = new DefaultRowHandler();</span>
<span class="fc" id="L398">          handleResults(statementScope, rs, skipResults, maxResults, new RowHandlerCallback(rm, null, rh));</span>
<span class="fc" id="L399">          multipleResults.add(rh.getList());</span>
<span class="fc" id="L400">          i++;</span>
<span class="fc" id="L401">        }</span>
<span class="fc" id="L402">        defaultRowHandler.setList(multipleResults);</span>
<span class="fc" id="L403">        statementScope.setResultMap(statement.getResultMap());</span>
<span class="fc" id="L404">      } else {</span>
<span class="pc bpc" id="L405" title="1 of 2 branches missed.">        while (moveToNextResultsSafely(statementScope, ps)) {</span>
          ;
        }
      }
    }
    // End additional ResultSet handling
<span class="fc" id="L411">    return rs;</span>
  }

  /**
   * Gets the first result set.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return the first result set
   *
   * @throws SQLException
   *           the SQL exception
   */
  private ResultSet getFirstResultSet(StatementScope scope, Statement stmt) throws SQLException {
<span class="fc" id="L428">    ResultSet rs = null;</span>
<span class="fc" id="L429">    boolean hasMoreResults = true;</span>
<span class="pc bpc" id="L430" title="1 of 2 branches missed.">    while (hasMoreResults) {</span>
<span class="fc" id="L431">      rs = stmt.getResultSet();</span>
<span class="pc bpc" id="L432" title="1 of 2 branches missed.">      if (rs != null) {</span>
<span class="fc" id="L433">        break;</span>
      }
<span class="nc" id="L435">      hasMoreResults = moveToNextResultsIfPresent(scope, stmt);</span>
    }
<span class="fc" id="L437">    return rs;</span>
  }

  /**
   * Move to next results if present.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if successful
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean moveToNextResultsIfPresent(StatementScope scope, Statement stmt) throws SQLException {
    boolean moreResults;
    // This is the messed up JDBC approach for determining if there are more results
<span class="nc" id="L456">    boolean movedToNextResultsSafely = moveToNextResultsSafely(scope, stmt);</span>
<span class="nc" id="L457">    int updateCount = stmt.getUpdateCount();</span>

<span class="nc bnc" id="L459" title="All 4 branches missed.">    moreResults = !(!movedToNextResultsSafely &amp;&amp; (updateCount == -1));</span>

    // ibatis-384: workaround for mysql not returning -1 for stmt.getUpdateCount()
<span class="nc bnc" id="L462" title="All 2 branches missed.">    if (moreResults == true) {</span>
<span class="nc bnc" id="L463" title="All 4 branches missed.">      moreResults = !(!movedToNextResultsSafely &amp;&amp; !isMultipleResultSetSupportPresent(scope, stmt));</span>
    }

<span class="nc" id="L466">    return moreResults;</span>
  }

  /**
   * Move to next results safely.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if successful
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean moveToNextResultsSafely(StatementScope scope, Statement stmt) throws SQLException {
<span class="pc bpc" id="L483" title="1 of 2 branches missed.">    if (isMultipleResultSetSupportPresent(scope, stmt)) {</span>
<span class="fc" id="L484">      return stmt.getMoreResults();</span>
    }
<span class="nc" id="L486">    return false;</span>
  }

  /**
   * checks whether multiple result set support is present - either by direct support of the database driver or by
   * forcing it.
   *
   * @param scope
   *          the scope
   * @param stmt
   *          the stmt
   *
   * @return true, if is multiple result set support present
   *
   * @throws SQLException
   *           the SQL exception
   */
  private boolean isMultipleResultSetSupportPresent(StatementScope scope, Statement stmt) throws SQLException {
<span class="pc bpc" id="L504" title="2 of 4 branches missed.">    return forceMultipleResultSetSupport(scope) || stmt.getConnection().getMetaData().supportsMultipleResultSets();</span>
  }

  /**
   * Force multiple result set support.
   *
   * @param scope
   *          the scope
   *
   * @return true, if successful
   */
  private boolean forceMultipleResultSetSupport(StatementScope scope) {
<span class="fc" id="L516">    return ((SqlMapClientImpl) scope.getSession().getSqlMapClient()).getDelegate().isForceMultipleResultSetSupport();</span>
  }

  /**
   * Handle results.
   *
   * @param statementScope
   *          the statement scope
   * @param rs
   *          the rs
   * @param skipResults
   *          the skip results
   * @param maxResults
   *          the max results
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void handleResults(StatementScope statementScope, ResultSet rs, int skipResults, int maxResults,
      RowHandlerCallback callback) throws SQLException {
    try {
<span class="fc" id="L539">      statementScope.setResultSet(rs);</span>
<span class="fc" id="L540">      ResultMap resultMap = statementScope.getResultMap();</span>
<span class="pc bpc" id="L541" title="1 of 2 branches missed.">      if (resultMap != null) {</span>
        // Skip Results
<span class="pc bpc" id="L543" title="1 of 2 branches missed.">        if (rs.getType() != ResultSet.TYPE_FORWARD_ONLY) {</span>
<span class="nc bnc" id="L544" title="All 2 branches missed.">          if (skipResults &gt; 0) {</span>
<span class="nc" id="L545">            rs.absolute(skipResults);</span>
          }
        } else {
<span class="fc bfc" id="L548" title="All 2 branches covered.">          for (int i = 0; i &lt; skipResults; i++) {</span>
<span class="fc bfc" id="L549" title="All 2 branches covered.">            if (!rs.next()) {</span>
<span class="fc" id="L550">              return;</span>
            }
          }
        }

        // Get Results
<span class="fc" id="L556">        int resultsFetched = 0;</span>
<span class="fc bfc" id="L557" title="All 6 branches covered.">        while ((maxResults == NO_MAXIMUM_RESULTS || resultsFetched &lt; maxResults) &amp;&amp; rs.next()) {</span>
<span class="fc" id="L558">          Object[] columnValues = resultMap.resolveSubMap(statementScope, rs).getResults(statementScope, rs);</span>
<span class="fc" id="L559">          callback.handleResultObject(statementScope, columnValues, rs);</span>
<span class="fc" id="L560">          resultsFetched++;</span>
<span class="fc" id="L561">        }</span>
      }
    } finally {
<span class="fc" id="L564">      statementScope.setResultSet(null);</span>
    }
<span class="fc" id="L566">  }</span>

  /**
   * Retrieve output parameters.
   *
   * @param statementScope
   *          the statement scope
   * @param cs
   *          the cs
   * @param mappings
   *          the mappings
   * @param parameters
   *          the parameters
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void retrieveOutputParameters(StatementScope statementScope, CallableStatement cs,
      ParameterMapping[] mappings, Object[] parameters, RowHandlerCallback callback) throws SQLException {
<span class="fc bfc" id="L587" title="All 2 branches covered.">    for (int i = 0; i &lt; mappings.length; i++) {</span>
<span class="fc" id="L588">      ParameterMapping mapping = mappings[i];</span>
<span class="pc bpc" id="L589" title="1 of 2 branches missed.">      if (mapping.isOutputAllowed()) {</span>
<span class="nc bnc" id="L590" title="All 2 branches missed.">        if (&quot;java.sql.ResultSet&quot;.equalsIgnoreCase(mapping.getJavaTypeName())) {</span>
<span class="nc" id="L591">          ResultSet rs = (ResultSet) cs.getObject(i + 1);</span>
          ResultMap resultMap;
<span class="nc bnc" id="L593" title="All 2 branches missed.">          if (mapping.getResultMapName() == null) {</span>
<span class="nc" id="L594">            resultMap = statementScope.getResultMap();</span>
<span class="nc" id="L595">            handleOutputParameterResults(statementScope, resultMap, rs, callback);</span>
          } else {
<span class="nc" id="L597">            SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="nc" id="L598">            resultMap = client.getDelegate().getResultMap(mapping.getResultMapName());</span>
<span class="nc" id="L599">            DefaultRowHandler rowHandler = new DefaultRowHandler();</span>
<span class="nc" id="L600">            RowHandlerCallback handlerCallback = new RowHandlerCallback(resultMap, null, rowHandler);</span>
<span class="nc" id="L601">            handleOutputParameterResults(statementScope, resultMap, rs, handlerCallback);</span>
<span class="nc" id="L602">            parameters[i] = rowHandler.getList();</span>
          }
<span class="nc" id="L604">          rs.close();</span>
<span class="nc" id="L605">        } else {</span>
<span class="nc" id="L606">          parameters[i] = mapping.getTypeHandler().getResult(cs, i + 1);</span>
        }
      }
    }
<span class="fc" id="L610">  }</span>

  /**
   * Register output parameters.
   *
   * @param cs
   *          the cs
   * @param mappings
   *          the mappings
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void registerOutputParameters(CallableStatement cs, ParameterMapping[] mappings) throws SQLException {
<span class="fc bfc" id="L624" title="All 2 branches covered.">    for (int i = 0; i &lt; mappings.length; i++) {</span>
<span class="fc" id="L625">      ParameterMapping mapping = mappings[i];</span>
<span class="pc bpc" id="L626" title="1 of 2 branches missed.">      if (mapping.isOutputAllowed()) {</span>
<span class="nc bnc" id="L627" title="All 4 branches missed.">        if (null != mapping.getTypeName() &amp;&amp; !mapping.getTypeName().equals(&quot;&quot;)) { // @added</span>
<span class="nc" id="L628">          cs.registerOutParameter(i + 1, mapping.getJdbcType(), mapping.getTypeName());</span>
        } else {
<span class="nc bnc" id="L630" title="All 2 branches missed.">          if (mapping.getNumericScale() != null</span>
<span class="nc bnc" id="L631" title="All 4 branches missed.">              &amp;&amp; (mapping.getJdbcType() == Types.NUMERIC || mapping.getJdbcType() == Types.DECIMAL)) {</span>
<span class="nc" id="L632">            cs.registerOutParameter(i + 1, mapping.getJdbcType(), mapping.getNumericScale().intValue());</span>
          } else {
<span class="nc" id="L634">            cs.registerOutParameter(i + 1, mapping.getJdbcType());</span>
          }
        }
      }
    }
<span class="fc" id="L639">  }</span>

  /**
   * Handle output parameter results.
   *
   * @param statementScope
   *          the statement scope
   * @param resultMap
   *          the result map
   * @param rs
   *          the rs
   * @param callback
   *          the callback
   *
   * @throws SQLException
   *           the SQL exception
   */
  private void handleOutputParameterResults(StatementScope statementScope, ResultMap resultMap, ResultSet rs,
      RowHandlerCallback callback) throws SQLException {
<span class="nc" id="L658">    ResultMap orig = statementScope.getResultMap();</span>
    try {
<span class="nc" id="L660">      statementScope.setResultSet(rs);</span>
<span class="nc bnc" id="L661" title="All 2 branches missed.">      if (resultMap != null) {</span>
<span class="nc" id="L662">        statementScope.setResultMap(resultMap);</span>

        // Get Results
<span class="nc bnc" id="L665" title="All 2 branches missed.">        while (rs.next()) {</span>
<span class="nc" id="L666">          Object[] columnValues = resultMap.resolveSubMap(statementScope, rs).getResults(statementScope, rs);</span>
<span class="nc" id="L667">          callback.handleResultObject(statementScope, columnValues, rs);</span>
<span class="nc" id="L668">        }</span>
      }
    } finally {
<span class="nc" id="L671">      statementScope.setResultSet(null);</span>
<span class="nc" id="L672">      statementScope.setResultMap(orig);</span>
    }
<span class="nc" id="L674">  }</span>

  /**
   * Clean up any batches on the session
   *
   * @param sessionScope
   *          - the session to clean up
   */
  @Override
  public void cleanup(SessionScope sessionScope) {
<span class="fc" id="L684">    Batch batch = (Batch) sessionScope.getBatch();</span>
<span class="fc bfc" id="L685" title="All 2 branches covered.">    if (batch != null) {</span>
<span class="fc" id="L686">      batch.cleanupBatch(sessionScope);</span>
<span class="fc" id="L687">      sessionScope.setBatch(null);</span>
    }
<span class="fc" id="L689">  }</span>

  /**
   * Prepare statement.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   * @param rsType
   *          the rs type
   *
   * @return the prepared statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private PreparedStatement prepareStatement(SessionScope sessionScope, Connection conn, String sql, Integer rsType)
      throws SQLException {
<span class="nc" id="L710">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="nc bnc" id="L711" title="All 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L712">      return sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="nc" id="L714">      PreparedStatement ps = conn.prepareStatement(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);</span>
<span class="nc" id="L715">      sessionScope.putPreparedStatement(delegate, sql, ps);</span>
<span class="nc" id="L716">      return ps;</span>
    }
  }

  /**
   * Prepare call.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   * @param rsType
   *          the rs type
   *
   * @return the callable statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private CallableStatement prepareCall(SessionScope sessionScope, Connection conn, String sql, Integer rsType)
      throws SQLException {
<span class="nc" id="L739">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="nc bnc" id="L740" title="All 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L741">      return (CallableStatement) sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="nc" id="L743">      CallableStatement cs = conn.prepareCall(sql, rsType.intValue(), ResultSet.CONCUR_READ_ONLY);</span>
<span class="nc" id="L744">      sessionScope.putPreparedStatement(delegate, sql, cs);</span>
<span class="nc" id="L745">      return cs;</span>
    }
  }

  /**
   * Prepare statement.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   *
   * @return the prepared statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private static PreparedStatement prepareStatement(SessionScope sessionScope, Connection conn, String sql)
      throws SQLException {
<span class="fc" id="L766">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="fc bfc" id="L767" title="All 2 branches covered.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="fc" id="L768">      return sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="fc" id="L770">      PreparedStatement ps = conn.prepareStatement(sql);</span>
<span class="fc" id="L771">      sessionScope.putPreparedStatement(delegate, sql, ps);</span>
<span class="fc" id="L772">      return ps;</span>
    }
  }

  /**
   * Prepare call.
   *
   * @param sessionScope
   *          the session scope
   * @param conn
   *          the conn
   * @param sql
   *          the sql
   *
   * @return the callable statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private CallableStatement prepareCall(SessionScope sessionScope, Connection conn, String sql) throws SQLException {
<span class="fc" id="L792">    SqlMapExecutorDelegate delegate = ((SqlMapClientImpl) sessionScope.getSqlMapExecutor()).getDelegate();</span>
<span class="pc bpc" id="L793" title="1 of 2 branches missed.">    if (sessionScope.hasPreparedStatementFor(sql)) {</span>
<span class="nc" id="L794">      return (CallableStatement) sessionScope.getPreparedStatement((sql));</span>
    } else {
<span class="fc" id="L796">      CallableStatement cs = conn.prepareCall(sql);</span>
<span class="fc" id="L797">      sessionScope.putPreparedStatement(delegate, sql, cs);</span>
<span class="fc" id="L798">      return cs;</span>
    }
  }

  /**
   * Close statement.
   *
   * @param sessionScope
   *          the session scope
   * @param ps
   *          the ps
   */
  private static void closeStatement(SessionScope sessionScope, PreparedStatement ps) {
<span class="fc bfc" id="L811" title="All 2 branches covered.">    if (ps != null) {</span>
<span class="fc bfc" id="L812" title="All 2 branches covered.">      if (!sessionScope.hasPreparedStatement(ps)) {</span>
        try {
<span class="fc" id="L814">          ps.close();</span>
<span class="nc" id="L815">        } catch (SQLException e) {</span>
          // ignore
<span class="fc" id="L817">        }</span>
      }
    }
<span class="fc" id="L820">  }</span>

  /**
   * Close result set.
   *
   * @param rs
   *          the rs
   */
  private static void closeResultSet(ResultSet rs) {
<span class="fc bfc" id="L829" title="All 2 branches covered.">    if (rs != null) {</span>
      try {
<span class="fc" id="L831">        rs.close();</span>
<span class="nc" id="L832">      } catch (SQLException e) {</span>
        // ignore
<span class="fc" id="L834">      }</span>
    }
<span class="fc" id="L836">  }</span>

  /**
   * Sets the statement timeout.
   *
   * @param mappedStatement
   *          the mapped statement
   * @param statement
   *          the statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  private static void setStatementTimeout(MappedStatement mappedStatement, Statement statement) throws SQLException {
<span class="pc bpc" id="L850" title="1 of 2 branches missed.">    if (mappedStatement.getTimeout() != null) {</span>
<span class="nc" id="L851">      statement.setQueryTimeout(mappedStatement.getTimeout().intValue());</span>
    }
<span class="fc" id="L853">  }</span>

  /**
   * The Class Batch.
   */
  private static class Batch {

    /** The current sql. */
    private String currentSql;

    /** The statement list. */
<span class="fc" id="L864">    private List statementList = new ArrayList&lt;&gt;();</span>

    /** The batch result list. */
<span class="fc" id="L867">    private List batchResultList = new ArrayList&lt;&gt;();</span>

    /** The size. */
    private int size;

    /**
     * Create a new batch.
     */
<span class="fc" id="L875">    public Batch() {</span>
<span class="fc" id="L876">      this.size = 0;</span>
<span class="fc" id="L877">    }</span>

    /**
     * Getter for the batch size.
     *
     * @return - the batch size
     */
    public int getSize() {
<span class="nc" id="L885">      return size;</span>
    }

    /**
     * Add a prepared statement to the batch.
     *
     * @param statementScope
     *          - the request scope
     * @param conn
     *          - the database connection
     * @param sql
     *          - the SQL to add
     * @param parameters
     *          - the parameters for the SQL
     *
     * @throws SQLException
     *           - if the prepare for the SQL fails
     */
    public void addBatch(StatementScope statementScope, Connection conn, String sql, Object[] parameters)
        throws SQLException {
<span class="fc" id="L905">      PreparedStatement ps = null;</span>
<span class="fc bfc" id="L906" title="All 4 branches covered.">      if (currentSql != null &amp;&amp; currentSql.equals(sql)) {</span>
<span class="fc" id="L907">        int last = statementList.size() - 1;</span>
<span class="fc" id="L908">        ps = (PreparedStatement) statementList.get(last);</span>
<span class="fc" id="L909">      } else {</span>
<span class="fc" id="L910">        ps = prepareStatement(statementScope.getSession(), conn, sql);</span>
<span class="fc" id="L911">        setStatementTimeout(statementScope.getStatement(), ps);</span>
<span class="fc" id="L912">        currentSql = sql;</span>
<span class="fc" id="L913">        statementList.add(ps);</span>
<span class="fc" id="L914">        batchResultList.add(new BatchResult(statementScope.getStatement().getId(), sql));</span>
      }
<span class="fc" id="L916">      statementScope.getParameterMap().setParameters(statementScope, ps, parameters);</span>
<span class="fc" id="L917">      ps.addBatch();</span>
<span class="fc" id="L918">      size++;</span>
<span class="fc" id="L919">    }</span>

    /**
     * TODO (Jeff Butler) - maybe this method should be deprecated in some release, and then removed in some even later
     * release. executeBatchDetailed gives much more complete information.
     * &lt;p&gt;
     * Execute the current session's batch
     *
     * @return - the number of rows updated
     *
     * @throws SQLException
     *           - if the batch fails
     */
    public int executeBatch() throws SQLException {
<span class="fc" id="L933">      int totalRowCount = 0;</span>
<span class="fc bfc" id="L934" title="All 2 branches covered.">      for (Object element : statementList) {</span>
<span class="fc" id="L935">        PreparedStatement ps = (PreparedStatement) element;</span>
<span class="fc" id="L936">        int[] rowCounts = ps.executeBatch();</span>
<span class="fc bfc" id="L937" title="All 2 branches covered.">        for (int j = 0; j &lt; rowCounts.length; j++) {</span>
<span class="pc bpc" id="L938" title="1 of 2 branches missed.">          if (rowCounts[j] == Statement.SUCCESS_NO_INFO) {</span>
            // do nothing
<span class="pc bpc" id="L940" title="1 of 2 branches missed.">          } else if (rowCounts[j] == Statement.EXECUTE_FAILED) {</span>
<span class="nc" id="L941">            throw new SQLException(&quot;The batched statement at index &quot; + j + &quot; failed to execute.&quot;);</span>
          } else {
<span class="fc" id="L943">            totalRowCount += rowCounts[j];</span>
          }
        }
<span class="fc" id="L946">      }</span>
<span class="fc" id="L947">      return totalRowCount;</span>
    }

    /**
     * Batch execution method that returns all the information the driver has to offer.
     *
     * @return a List of BatchResult objects
     *
     * @throws SQLException
     *           if a database access error occurs, or the drive does not support batch statements
     * @throws BatchException
     *           if the driver throws BatchUpdateException
     */
    public List executeBatchDetailed() throws SQLException, BatchException {
<span class="fc" id="L961">      List answer = new ArrayList&lt;&gt;();</span>
<span class="fc bfc" id="L962" title="All 2 branches covered.">      for (int i = 0, n = statementList.size(); i &lt; n; i++) {</span>
<span class="fc" id="L963">        BatchResult br = (BatchResult) batchResultList.get(i);</span>
<span class="fc" id="L964">        PreparedStatement ps = (PreparedStatement) statementList.get(i);</span>
        try {
<span class="fc" id="L966">          br.setUpdateCounts(ps.executeBatch());</span>
<span class="fc" id="L967">        } catch (BatchUpdateException e) {</span>
<span class="fc" id="L968">          StringBuilder message = new StringBuilder();</span>
<span class="fc" id="L969">          message.append(&quot;Sub batch number &quot;);</span>
<span class="fc" id="L970">          message.append(i + 1);</span>
<span class="fc" id="L971">          message.append(&quot; failed.&quot;);</span>
<span class="pc bpc" id="L972" title="1 of 2 branches missed.">          if (i &gt; 0) {</span>
<span class="fc" id="L973">            message.append(&quot; &quot;);</span>
<span class="fc" id="L974">            message.append(i);</span>
<span class="fc" id="L975">            message.append(&quot; prior sub batch(s) completed successfully, but will be rolled back.&quot;);</span>
          }
<span class="fc" id="L977">          throw new BatchException(message.toString(), e, answer, br.getStatementId(), br.getSql());</span>
<span class="fc" id="L978">        }</span>
<span class="fc" id="L979">        answer.add(br);</span>
      }
<span class="fc" id="L981">      return answer;</span>
    }

    /**
     * Close all the statements in the batch and clear all the statements.
     *
     * @param sessionScope
     *          the session scope
     */
    public void cleanupBatch(SessionScope sessionScope) {
<span class="fc bfc" id="L991" title="All 2 branches covered.">      for (Object element : statementList) {</span>
<span class="fc" id="L992">        PreparedStatement ps = (PreparedStatement) element;</span>
<span class="fc" id="L993">        closeStatement(sessionScope, ps);</span>
<span class="fc" id="L994">      }</span>
<span class="fc" id="L995">      currentSql = null;</span>
<span class="fc" id="L996">      statementList.clear();</span>
<span class="fc" id="L997">      batchResultList.clear();</span>
<span class="fc" id="L998">      size = 0;</span>
<span class="fc" id="L999">    }</span>
  }

  /**
   * Sets the up result object factory.
   *
   * @param statementScope
   *          the new up result object factory
   */
  private void setupResultObjectFactory(StatementScope statementScope) {
<span class="fc" id="L1009">    SqlMapClientImpl client = (SqlMapClientImpl) statementScope.getSession().getSqlMapClient();</span>
<span class="fc" id="L1010">    ResultObjectFactoryUtil.setupResultObjectFactory(client.getResultObjectFactory(),</span>
<span class="fc" id="L1011">        statementScope.getStatement().getId());</span>
<span class="fc" id="L1012">  }</span>

  /**
   * Cleanup result object factory.
   */
  private void cleanupResultObjectFactory() {
<span class="fc" id="L1018">    ResultObjectFactoryUtil.cleanupResultObjectFactory();</span>
<span class="fc" id="L1019">  }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.13.202504020838</span></div></body></html>