<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>MappedStatementConfig.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.config</a> &gt; <span class="el_source">MappedStatementConfig.java</span></div><h1>MappedStatementConfig.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.config;

import com.ibatis.common.beans.*;
import com.ibatis.common.resources.*;
import com.ibatis.sqlmap.client.*;
import com.ibatis.sqlmap.engine.cache.*;
import com.ibatis.sqlmap.engine.impl.*;
import com.ibatis.sqlmap.engine.mapping.parameter.*;
import com.ibatis.sqlmap.engine.mapping.result.*;
import com.ibatis.sqlmap.engine.mapping.sql.*;
import com.ibatis.sqlmap.engine.mapping.sql.dynamic.*;
import com.ibatis.sqlmap.engine.mapping.sql.simple.*;
import com.ibatis.sqlmap.engine.mapping.sql.stat.*;
import com.ibatis.sqlmap.engine.mapping.statement.*;
import com.ibatis.sqlmap.engine.scope.*;
import com.ibatis.sqlmap.engine.type.*;

import java.sql.ResultSet;
import java.util.*;

/**
 * The Class MappedStatementConfig.
 */
public class MappedStatementConfig {

  /** The Constant PROBE. */
<span class="fc" id="L42">  private static final Probe PROBE = ProbeFactory.getProbe();</span>

  /** The Constant PARAM_PARSER. */
<span class="fc" id="L45">  private static final InlineParameterMapParser PARAM_PARSER = new InlineParameterMapParser();</span>

  /** The error context. */
  private ErrorContext errorContext;

  /** The client. */
  private SqlMapClientImpl client;

  /** The type handler factory. */
  private TypeHandlerFactory typeHandlerFactory;

  /** The mapped statement. */
  private MappedStatement mappedStatement;

  /** The root statement. */
  private MappedStatement rootStatement;

  /**
   * Instantiates a new mapped statement config.
   *
   * @param config
   *          the config
   * @param id
   *          the id
   * @param statement
   *          the statement
   * @param processor
   *          the processor
   * @param parameterMapName
   *          the parameter map name
   * @param parameterClass
   *          the parameter class
   * @param resultMapName
   *          the result map name
   * @param additionalResultMapNames
   *          the additional result map names
   * @param resultClass
   *          the result class
   * @param additionalResultClasses
   *          the additional result classes
   * @param cacheModelName
   *          the cache model name
   * @param resultSetType
   *          the result set type
   * @param fetchSize
   *          the fetch size
   * @param allowRemapping
   *          the allow remapping
   * @param timeout
   *          the timeout
   * @param defaultStatementTimeout
   *          the default statement timeout
   * @param xmlResultName
   *          the xml result name
   */
  MappedStatementConfig(SqlMapConfiguration config, String id, MappedStatement statement, SqlSource processor,
      String parameterMapName, Class parameterClass, String resultMapName, String[] additionalResultMapNames,
      Class resultClass, Class[] additionalResultClasses, String cacheModelName, String resultSetType,
      Integer fetchSize, boolean allowRemapping, Integer timeout, Integer defaultStatementTimeout,
<span class="fc" id="L104">      String xmlResultName) {</span>
<span class="fc" id="L105">    this.errorContext = config.getErrorContext();</span>
<span class="fc" id="L106">    this.client = config.getClient();</span>
<span class="fc" id="L107">    SqlMapExecutorDelegate delegate = client.getDelegate();</span>
<span class="fc" id="L108">    this.typeHandlerFactory = config.getTypeHandlerFactory();</span>
<span class="fc" id="L109">    errorContext.setActivity(&quot;parsing a mapped statement&quot;);</span>
<span class="fc" id="L110">    errorContext.setObjectId(id + &quot; statement&quot;);</span>
<span class="fc" id="L111">    errorContext.setMoreInfo(&quot;Check the result map name.&quot;);</span>
<span class="fc bfc" id="L112" title="All 2 branches covered.">    if (resultMapName != null) {</span>
<span class="fc" id="L113">      statement.setResultMap(client.getDelegate().getResultMap(resultMapName));</span>
<span class="pc bpc" id="L114" title="1 of 2 branches missed.">      if (additionalResultMapNames != null) {</span>
<span class="fc bfc" id="L115" title="All 2 branches covered.">        for (int i = 0; i &lt; additionalResultMapNames.length; i++) {</span>
<span class="fc" id="L116">          statement.addResultMap(client.getDelegate().getResultMap(additionalResultMapNames[i]));</span>
        }
      }
    }
<span class="fc" id="L120">    errorContext.setMoreInfo(&quot;Check the parameter map name.&quot;);</span>
<span class="fc bfc" id="L121" title="All 2 branches covered.">    if (parameterMapName != null) {</span>
<span class="fc" id="L122">      statement.setParameterMap(client.getDelegate().getParameterMap(parameterMapName));</span>
    }
<span class="fc" id="L124">    statement.setId(id);</span>
<span class="fc" id="L125">    statement.setResource(errorContext.getResource());</span>
<span class="pc bpc" id="L126" title="1 of 2 branches missed.">    if (resultSetType != null) {</span>
<span class="nc bnc" id="L127" title="All 2 branches missed.">      if (&quot;FORWARD_ONLY&quot;.equals(resultSetType)) {</span>
<span class="nc" id="L128">        statement.setResultSetType(Integer.valueOf(ResultSet.TYPE_FORWARD_ONLY));</span>
<span class="nc bnc" id="L129" title="All 2 branches missed.">      } else if (&quot;SCROLL_INSENSITIVE&quot;.equals(resultSetType)) {</span>
<span class="nc" id="L130">        statement.setResultSetType(Integer.valueOf(ResultSet.TYPE_SCROLL_INSENSITIVE));</span>
<span class="nc bnc" id="L131" title="All 2 branches missed.">      } else if (&quot;SCROLL_SENSITIVE&quot;.equals(resultSetType)) {</span>
<span class="nc" id="L132">        statement.setResultSetType(Integer.valueOf(ResultSet.TYPE_SCROLL_SENSITIVE));</span>
      }
    }
<span class="pc bpc" id="L135" title="1 of 2 branches missed.">    if (fetchSize != null) {</span>
<span class="nc" id="L136">      statement.setFetchSize(fetchSize);</span>
    }

    // set parameter class either from attribute or from map (make sure to match)
<span class="fc" id="L140">    ParameterMap parameterMap = statement.getParameterMap();</span>
<span class="fc bfc" id="L141" title="All 2 branches covered.">    if (parameterMap == null) {</span>
<span class="fc" id="L142">      statement.setParameterClass(parameterClass);</span>
    } else {
<span class="fc" id="L144">      statement.setParameterClass(parameterMap.getParameterClass());</span>
    }

    // process SQL statement, including inline parameter maps
<span class="fc" id="L148">    errorContext.setMoreInfo(&quot;Check the SQL statement.&quot;);</span>
<span class="fc" id="L149">    Sql sql = processor.getSql();</span>
<span class="fc" id="L150">    setSqlForStatement(statement, sql);</span>

    // set up either null result map or automatic result mapping
<span class="fc" id="L153">    ResultMap resultMap = (ResultMap) statement.getResultMap();</span>
<span class="fc bfc" id="L154" title="All 4 branches covered.">    if (resultMap == null &amp;&amp; resultClass == null) {</span>
<span class="fc" id="L155">      statement.setResultMap(null);</span>
<span class="fc bfc" id="L156" title="All 2 branches covered.">    } else if (resultMap == null) {</span>
<span class="fc" id="L157">      resultMap = buildAutoResultMap(allowRemapping, statement, resultClass, xmlResultName);</span>
<span class="fc" id="L158">      statement.setResultMap(resultMap);</span>
<span class="pc bpc" id="L159" title="1 of 2 branches missed.">      if (additionalResultClasses != null) {</span>
<span class="fc bfc" id="L160" title="All 2 branches covered.">        for (int i = 0; i &lt; additionalResultClasses.length; i++) {</span>
<span class="fc" id="L161">          statement</span>
<span class="fc" id="L162">              .addResultMap(buildAutoResultMap(allowRemapping, statement, additionalResultClasses[i], xmlResultName));</span>
        }
      }

    }
<span class="fc" id="L167">    statement.setTimeout(defaultStatementTimeout);</span>
<span class="pc bpc" id="L168" title="1 of 2 branches missed.">    if (timeout != null) {</span>
      try {
<span class="nc" id="L170">        statement.setTimeout(timeout);</span>
<span class="nc" id="L171">      } catch (NumberFormatException e) {</span>
<span class="nc" id="L172">        throw new SqlMapException(</span>
<span class="nc" id="L173">            &quot;Specified timeout value for statement &quot; + statement.getId() + &quot; is not a valid integer&quot;);</span>
<span class="nc" id="L174">      }</span>
    }
<span class="fc" id="L176">    errorContext.setMoreInfo(null);</span>
<span class="fc" id="L177">    errorContext.setObjectId(null);</span>
<span class="fc" id="L178">    statement.setSqlMapClient(client);</span>
<span class="pc bpc" id="L179" title="2 of 6 branches missed.">    if (cacheModelName != null &amp;&amp; cacheModelName.length() &gt; 0 &amp;&amp; client.getDelegate().isCacheModelsEnabled()) {</span>
<span class="fc" id="L180">      CacheModel cacheModel = client.getDelegate().getCacheModel(cacheModelName);</span>
<span class="fc" id="L181">      mappedStatement = new CachingStatement(statement, cacheModel);</span>
<span class="fc" id="L182">    } else {</span>
<span class="fc" id="L183">      mappedStatement = statement;</span>
    }
<span class="fc" id="L185">    rootStatement = statement;</span>
<span class="fc" id="L186">    delegate.addMappedStatement(mappedStatement);</span>
<span class="fc" id="L187">  }</span>

  /**
   * Sets the select key statement.
   *
   * @param processor
   *          the processor
   * @param resultClassName
   *          the result class name
   * @param keyPropName
   *          the key prop name
   * @param runAfterSQL
   *          the run after SQL
   * @param type
   *          the type
   */
  public void setSelectKeyStatement(SqlSource processor, String resultClassName, String keyPropName,
      boolean runAfterSQL, String type) {
<span class="pc bpc" id="L205" title="1 of 2 branches missed.">    if (rootStatement instanceof InsertStatement) {</span>
<span class="fc" id="L206">      InsertStatement insertStatement = ((InsertStatement) rootStatement);</span>
<span class="fc" id="L207">      Class parameterClass = insertStatement.getParameterClass();</span>
<span class="fc" id="L208">      errorContext.setActivity(&quot;parsing a select key&quot;);</span>
<span class="fc" id="L209">      SelectKeyStatement selectKeyStatement = new SelectKeyStatement();</span>
<span class="fc" id="L210">      resultClassName = typeHandlerFactory.resolveAlias(resultClassName);</span>
<span class="fc" id="L211">      Class resultClass = null;</span>

      // get parameter and result maps
<span class="fc" id="L214">      selectKeyStatement.setSqlMapClient(client);</span>
<span class="fc" id="L215">      selectKeyStatement.setId(insertStatement.getId() + &quot;-SelectKey&quot;);</span>
<span class="fc" id="L216">      selectKeyStatement.setResource(errorContext.getResource());</span>
<span class="fc" id="L217">      selectKeyStatement.setKeyProperty(keyPropName);</span>
<span class="fc" id="L218">      selectKeyStatement.setRunAfterSQL(runAfterSQL);</span>
      // process the type (pre or post) attribute
<span class="fc bfc" id="L220" title="All 2 branches covered.">      if (type != null) {</span>
<span class="fc" id="L221">        selectKeyStatement.setRunAfterSQL(&quot;post&quot;.equals(type));</span>
      }
      try {
<span class="pc bpc" id="L224" title="1 of 2 branches missed.">        if (resultClassName != null) {</span>
<span class="fc" id="L225">          errorContext.setMoreInfo(&quot;Check the select key result class.&quot;);</span>
<span class="fc" id="L226">          resultClass = Resources.classForName(resultClassName);</span>
        } else {
<span class="nc bnc" id="L228" title="All 4 branches missed.">          if (keyPropName != null &amp;&amp; parameterClass != null) {</span>
<span class="nc" id="L229">            resultClass = PROBE.getPropertyTypeForSetter(parameterClass, selectKeyStatement.getKeyProperty());</span>
          }
        }
<span class="nc" id="L232">      } catch (ClassNotFoundException e) {</span>
<span class="nc" id="L233">        throw new SqlMapException(&quot;Error.  Could not set result class.  Cause: &quot; + e, e);</span>
<span class="fc" id="L234">      }</span>
<span class="pc bpc" id="L235" title="1 of 2 branches missed.">      if (resultClass == null) {</span>
<span class="nc" id="L236">        resultClass = Object.class;</span>
      }

      // process SQL statement, including inline parameter maps
<span class="fc" id="L240">      errorContext.setMoreInfo(&quot;Check the select key SQL statement.&quot;);</span>
<span class="fc" id="L241">      Sql sql = processor.getSql();</span>
<span class="fc" id="L242">      setSqlForStatement(selectKeyStatement, sql);</span>
      ResultMap resultMap;
<span class="fc" id="L244">      resultMap = new AutoResultMap(client.getDelegate(), false);</span>
<span class="fc" id="L245">      resultMap.setId(selectKeyStatement.getId() + &quot;-AutoResultMap&quot;);</span>
<span class="fc" id="L246">      resultMap.setResultClass(resultClass);</span>
<span class="fc" id="L247">      resultMap.setResource(selectKeyStatement.getResource());</span>
<span class="fc" id="L248">      selectKeyStatement.setResultMap(resultMap);</span>
<span class="fc" id="L249">      errorContext.setMoreInfo(null);</span>
<span class="fc" id="L250">      insertStatement.setSelectKeyStatement(selectKeyStatement);</span>
<span class="fc" id="L251">    } else {</span>
<span class="nc" id="L252">      throw new SqlMapException(&quot;You cant set a select key statement on statement named &quot; + rootStatement.getId()</span>
          + &quot; because it is not an InsertStatement.&quot;);
    }
<span class="fc" id="L255">  }</span>

  /**
   * Sets the sql for statement.
   *
   * @param statement
   *          the statement
   * @param sql
   *          the sql
   */
  private void setSqlForStatement(MappedStatement statement, Sql sql) {
<span class="fc bfc" id="L266" title="All 2 branches covered.">    if (sql instanceof DynamicSql) {</span>
<span class="fc" id="L267">      statement.setSql(sql);</span>
    } else {
<span class="fc" id="L269">      applyInlineParameterMap(statement, sql.getSql(null, null));</span>
    }
<span class="fc" id="L271">  }</span>

  /**
   * Apply inline parameter map.
   *
   * @param statement
   *          the statement
   * @param sqlStatement
   *          the sql statement
   */
  private void applyInlineParameterMap(MappedStatement statement, String sqlStatement) {
<span class="fc" id="L282">    String newSql = sqlStatement;</span>
<span class="fc" id="L283">    errorContext.setActivity(&quot;building an inline parameter map&quot;);</span>
<span class="fc" id="L284">    ParameterMap parameterMap = statement.getParameterMap();</span>
<span class="fc" id="L285">    errorContext.setMoreInfo(&quot;Check the inline parameters.&quot;);</span>
<span class="fc bfc" id="L286" title="All 2 branches covered.">    if (parameterMap == null) {</span>
      ParameterMap map;
<span class="fc" id="L288">      map = new ParameterMap(client.getDelegate());</span>
<span class="fc" id="L289">      map.setId(statement.getId() + &quot;-InlineParameterMap&quot;);</span>
<span class="fc" id="L290">      map.setParameterClass(statement.getParameterClass());</span>
<span class="fc" id="L291">      map.setResource(statement.getResource());</span>
<span class="fc" id="L292">      statement.setParameterMap(map);</span>
<span class="fc" id="L293">      SqlText sqlText = PARAM_PARSER.parseInlineParameterMap(client.getDelegate().getTypeHandlerFactory(), newSql,</span>
<span class="fc" id="L294">          statement.getParameterClass());</span>
<span class="fc" id="L295">      newSql = sqlText.getText();</span>
<span class="fc" id="L296">      List mappingList = Arrays.asList(sqlText.getParameterMappings());</span>
<span class="fc" id="L297">      map.setParameterMappingList(mappingList);</span>
    }
    Sql sql;
<span class="fc bfc" id="L300" title="All 2 branches covered.">    if (SimpleDynamicSql.isSimpleDynamicSql(newSql)) {</span>
<span class="fc" id="L301">      sql = new SimpleDynamicSql(client.getDelegate(), newSql);</span>
    } else {
<span class="fc" id="L303">      sql = new StaticSql(newSql);</span>
    }
<span class="fc" id="L305">    statement.setSql(sql);</span>

<span class="fc" id="L307">  }</span>

  /**
   * Builds the auto result map.
   *
   * @param allowRemapping
   *          the allow remapping
   * @param statement
   *          the statement
   * @param firstResultClass
   *          the first result class
   * @param xmlResultName
   *          the xml result name
   *
   * @return the result map
   */
  private ResultMap buildAutoResultMap(boolean allowRemapping, MappedStatement statement, Class firstResultClass,
      String xmlResultName) {
    ResultMap resultMap;
<span class="fc" id="L326">    resultMap = new AutoResultMap(client.getDelegate(), allowRemapping);</span>
<span class="fc" id="L327">    resultMap.setId(statement.getId() + &quot;-AutoResultMap&quot;);</span>
<span class="fc" id="L328">    resultMap.setResultClass(firstResultClass);</span>
<span class="fc" id="L329">    resultMap.setXmlName(xmlResultName);</span>
<span class="fc" id="L330">    resultMap.setResource(statement.getResource());</span>
<span class="fc" id="L331">    return resultMap;</span>
  }

  /**
   * Gets the mapped statement.
   *
   * @return the mapped statement
   */
  public MappedStatement getMappedStatement() {
<span class="nc" id="L340">    return mappedStatement;</span>
  }
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>