<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="en"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>SessionScope.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">mybatis2</a> &gt; <a href="index.source.html" class="el_package">com.ibatis.sqlmap.engine.scope</a> &gt; <span class="el_source">SessionScope.java</span></div><h1>SessionScope.java</h1><pre class="source lang-java linenums">/*
 * Copyright 2004-2022 the original author or authors.
 *
 * Licensed under the Apache License, Version 2.0 (the &quot;License&quot;);
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *    https://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package com.ibatis.sqlmap.engine.scope;

import com.ibatis.sqlmap.client.SqlMapClient;
import com.ibatis.sqlmap.client.SqlMapException;
import com.ibatis.sqlmap.client.SqlMapExecutor;
import com.ibatis.sqlmap.client.SqlMapTransactionManager;
import com.ibatis.sqlmap.engine.impl.SqlMapExecutorDelegate;
import com.ibatis.sqlmap.engine.transaction.Transaction;
import com.ibatis.sqlmap.engine.transaction.TransactionState;

import java.sql.PreparedStatement;
import java.sql.SQLException;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

/**
 * A Session based implementation of the Scope interface.
 */
public class SessionScope {

  /** The next id. */
  private static long nextId;

  /** The id. */
  private long id;

  /** The sql map client. */
  // Used by Any
  private SqlMapClient sqlMapClient;

  /** The sql map executor. */
  private SqlMapExecutor sqlMapExecutor;

  /** The sql map tx mgr. */
  private SqlMapTransactionManager sqlMapTxMgr;

  /** The request stack depth. */
  private int requestStackDepth;

  /** The transaction. */
  // Used by TransactionManager
  private Transaction transaction;

  /** The transaction state. */
  private TransactionState transactionState;

  /** The saved transaction state. */
  // Used by SqlMapExecutorDelegate.setUserProvidedTransaction()
  private TransactionState savedTransactionState;

  /** The in batch. */
  // Used by StandardSqlMapClient and GeneralStatement
  private boolean inBatch;

  /** The batch. */
  // Used by SqlExecutor
  private Object batch;

  /** The commit required. */
  private boolean commitRequired;

  /** The prepared statements. */
  private Map preparedStatements;

  /**
   * Default constructor.
   */
<span class="fc" id="L84">  public SessionScope() {</span>
<span class="fc" id="L85">    this.preparedStatements = new HashMap();</span>
<span class="fc" id="L86">    this.inBatch = false;</span>
<span class="fc" id="L87">    this.requestStackDepth = 0;</span>
<span class="fc" id="L88">    this.id = getNextId();</span>
<span class="fc" id="L89">  }</span>

  /**
   * Get the SqlMapClient for the session.
   *
   * @return - the SqlMapClient
   */
  public SqlMapClient getSqlMapClient() {
<span class="fc" id="L97">    return sqlMapClient;</span>
  }

  /**
   * Set the SqlMapClient for the session.
   *
   * @param sqlMapClient
   *          - the SqlMapClient
   */
  public void setSqlMapClient(SqlMapClient sqlMapClient) {
<span class="fc" id="L107">    this.sqlMapClient = sqlMapClient;</span>
<span class="fc" id="L108">  }</span>

  /**
   * Get the SQL executor for the session.
   *
   * @return - the SQL executor
   */
  public SqlMapExecutor getSqlMapExecutor() {
<span class="fc" id="L116">    return sqlMapExecutor;</span>
  }

  /**
   * Get the SQL executor for the session.
   *
   * @param sqlMapExecutor
   *          - the SQL executor
   */
  public void setSqlMapExecutor(SqlMapExecutor sqlMapExecutor) {
<span class="fc" id="L126">    this.sqlMapExecutor = sqlMapExecutor;</span>
<span class="fc" id="L127">  }</span>

  /**
   * Get the transaction manager.
   *
   * @return - the transaction manager
   */
  public SqlMapTransactionManager getSqlMapTxMgr() {
<span class="fc" id="L135">    return sqlMapTxMgr;</span>
  }

  /**
   * Set the transaction manager.
   *
   * @param sqlMapTxMgr
   *          - the transaction manager
   */
  public void setSqlMapTxMgr(SqlMapTransactionManager sqlMapTxMgr) {
<span class="fc" id="L145">    this.sqlMapTxMgr = sqlMapTxMgr;</span>
<span class="fc" id="L146">  }</span>

  /**
   * Tells us if we are in batch mode or not.
   *
   * @return - true if we are working with a batch
   */
  public boolean isInBatch() {
<span class="fc" id="L154">    return inBatch;</span>
  }

  /**
   * Turn batch mode on or off.
   *
   * @param inBatch
   *          - the switch
   */
  public void setInBatch(boolean inBatch) {
<span class="fc" id="L164">    this.inBatch = inBatch;</span>
<span class="fc" id="L165">  }</span>

  /**
   * Getter for the session transaction.
   *
   * @return - the transaction
   */
  public Transaction getTransaction() {
<span class="fc" id="L173">    return transaction;</span>
  }

  /**
   * Setter for the session transaction.
   *
   * @param transaction
   *          - the transaction
   */
  public void setTransaction(Transaction transaction) {
<span class="fc" id="L183">    this.transaction = transaction;</span>
<span class="fc" id="L184">  }</span>

  /**
   * Getter for the transaction state of the session.
   *
   * @return - the state
   */
  public TransactionState getTransactionState() {
<span class="fc" id="L192">    return transactionState;</span>
  }

  /**
   * Setter for the transaction state of the session.
   *
   * @param transactionState
   *          - the new transaction state
   */
  public void setTransactionState(TransactionState transactionState) {
<span class="fc" id="L202">    this.transactionState = transactionState;</span>
<span class="fc" id="L203">  }</span>

  /**
   * Getter for the batch of the session.
   *
   * @return - the batch
   */
  public Object getBatch() {
<span class="fc" id="L211">    return batch;</span>
  }

  /**
   * Stter for the batch of the session.
   *
   * @param batch
   *          the new batch
   */
  public void setBatch(Object batch) {
<span class="fc" id="L221">    this.batch = batch;</span>
<span class="fc" id="L222">  }</span>

  /**
   * Get the request stack depth.
   *
   * @return - the stack depth
   */
  public int getRequestStackDepth() {
<span class="fc" id="L230">    return requestStackDepth;</span>
  }

  /**
   * Increment the stack depth by one.
   */
  public void incrementRequestStackDepth() {
<span class="fc" id="L237">    requestStackDepth++;</span>
<span class="fc" id="L238">  }</span>

  /**
   * Decrement the stack depth by one.
   */
  public void decrementRequestStackDepth() {
<span class="fc" id="L244">    requestStackDepth--;</span>
<span class="fc" id="L245">  }</span>

  /**
   * Getter to tell if a commit is required for the session.
   *
   * @return - true if a commit is required
   */
  public boolean isCommitRequired() {
<span class="fc" id="L253">    return commitRequired;</span>
  }

  /**
   * Setter to tell the session that a commit is required for the session.
   *
   * @param commitRequired
   *          - the flag
   */
  public void setCommitRequired(boolean commitRequired) {
<span class="fc" id="L263">    this.commitRequired = commitRequired;</span>
<span class="fc" id="L264">  }</span>

  /**
   * Checks for prepared statement for.
   *
   * @param sql
   *          the sql
   *
   * @return true, if successful
   */
  public boolean hasPreparedStatementFor(String sql) {
<span class="fc" id="L275">    return preparedStatements.containsKey(sql);</span>
  }

  /**
   * Checks for prepared statement.
   *
   * @param ps
   *          the ps
   *
   * @return true, if successful
   */
  public boolean hasPreparedStatement(PreparedStatement ps) {
<span class="fc" id="L287">    return preparedStatements.containsValue(ps);</span>
  }

  /**
   * Gets the prepared statement.
   *
   * @param sql
   *          the sql
   *
   * @return the prepared statement
   *
   * @throws SQLException
   *           the SQL exception
   */
  public PreparedStatement getPreparedStatement(String sql) throws SQLException {
<span class="pc bpc" id="L302" title="1 of 2 branches missed.">    if (!hasPreparedStatementFor(sql))</span>
<span class="nc" id="L303">      throw new SqlMapException(&quot;Could not get prepared statement.  This is likely a bug.&quot;);</span>
<span class="fc" id="L304">    PreparedStatement ps = (PreparedStatement) preparedStatements.get(sql);</span>
<span class="fc" id="L305">    return ps;</span>
  }

  /**
   * Put prepared statement.
   *
   * @param delegate
   *          the delegate
   * @param sql
   *          the sql
   * @param ps
   *          the ps
   */
  public void putPreparedStatement(SqlMapExecutorDelegate delegate, String sql, PreparedStatement ps) {
<span class="fc bfc" id="L319" title="All 2 branches covered.">    if (delegate.isStatementCacheEnabled()) {</span>
<span class="pc bpc" id="L320" title="1 of 2 branches missed.">      if (!isInBatch()) {</span>
<span class="pc bpc" id="L321" title="1 of 2 branches missed.">        if (hasPreparedStatementFor(sql))</span>
<span class="nc" id="L322">          throw new SqlMapException(&quot;Duplicate prepared statement found.  This is likely a bug.&quot;);</span>
<span class="fc" id="L323">        preparedStatements.put(sql, ps);</span>
      }
    }
<span class="fc" id="L326">  }</span>

  /**
   * Close prepared statements.
   */
  public void closePreparedStatements() {
<span class="fc" id="L332">    Iterator keys = preparedStatements.keySet().iterator();</span>
<span class="fc bfc" id="L333" title="All 2 branches covered.">    while (keys.hasNext()) {</span>
<span class="fc" id="L334">      PreparedStatement ps = (PreparedStatement) preparedStatements.get(keys.next());</span>
      try {
<span class="fc" id="L336">        ps.close();</span>
<span class="nc" id="L337">      } catch (Exception e) {</span>
        // ignore -- we don't care if this fails at this point.
<span class="fc" id="L339">      }</span>
<span class="fc" id="L340">    }</span>
<span class="fc" id="L341">    preparedStatements.clear();</span>
<span class="fc" id="L342">  }</span>

  /**
   * Cleanup.
   */
  public void cleanup() {
<span class="fc" id="L348">    closePreparedStatements();</span>
<span class="fc" id="L349">    preparedStatements.clear();</span>
<span class="fc" id="L350">  }</span>

  @Override
  public boolean equals(Object parameterObject) {
<span class="nc bnc" id="L354" title="All 2 branches missed.">    if (this == parameterObject)</span>
<span class="nc" id="L355">      return true;</span>
<span class="nc bnc" id="L356" title="All 2 branches missed.">    if (!(parameterObject instanceof SessionScope))</span>
<span class="nc" id="L357">      return false;</span>
<span class="nc" id="L358">    final SessionScope sessionScope = (SessionScope) parameterObject;</span>
<span class="nc bnc" id="L359" title="All 2 branches missed.">    if (id != sessionScope.id)</span>
<span class="nc" id="L360">      return false;</span>
<span class="nc" id="L361">    return true;</span>
  }

  @Override
  public int hashCode() {
<span class="nc" id="L366">    return (int) (id ^ (id &gt;&gt;&gt; 32));</span>
  }

  /**
   * Method to get a unique ID.
   *
   * @return - the new ID
   */
  public synchronized static long getNextId() {
<span class="fc" id="L375">    return nextId++;</span>
  }

  /**
   * Saves the current transaction state.
   */
  public void saveTransactionState() {
<span class="fc" id="L382">    savedTransactionState = transactionState;</span>
<span class="fc" id="L383">  }</span>

  /**
   * Restores the previously saved transaction state.
   */
  public void recallTransactionState() {
<span class="nc" id="L389">    transactionState = savedTransactionState;</span>
<span class="nc" id="L390">  }</span>

}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.8.202204050719</span></div></body></html>